<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.webp" color="#222">
  <meta name="google-site-verification" content="Cj9oDgXxdJe6MoA_lEUQ2rmOouwJeTm5uJNqjhOv8Ng">
  <meta name="msvalidate.01" content="E5D0AA8F5E012DFD9C5F3954DF8283B1">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenxiaohai.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"twikoo","storage":true,"lazyload":false,"nav":null,"activeClass":"twikoo"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="CS131 Computer Vision： Foundations and Applications，Homework2：Edges-Smart Car Lane Detection。 重点在理解边缘检测，实现Canny算子，理解霍夫变换直线检测，以及利用Canny算子进行车道线检测。">
<meta property="og:type" content="article">
<meta property="og:title" content="CS131, Homewrok2, Edges-Smart Car Lane Detection">
<meta property="og:url" content="https://shenxiaohai.me/cs131-homework2/index.html">
<meta property="og:site_name" content="SHEN&#39;s DevNotes">
<meta property="og:description" content="CS131 Computer Vision： Foundations and Applications，Homework2：Edges-Smart Car Lane Detection。 重点在理解边缘检测，实现Canny算子，理解霍夫变换直线检测，以及利用Canny算子进行车道线检测。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509731/blog/qcoewrt08vrfd6g6kcre.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509731/blog/t2pkuuw45eiry6h6kpjc.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509732/blog/ooxa8ytiuyva9uqyy0jy.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509732/blog/ckl03zx9rnbfkliaws6i.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509733/blog/czpzsnkoxktmctyxfckc.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509733/blog/euk2k1v4efzm2f5pmg84.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509734/blog/sfond4qmlgla42tmwpxb.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509735/blog/uu1tz7suftbbdq90nxrh.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509735/blog/hawjmbzakcatysbx4lhd.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509736/blog/jsujhdnt74k9fkrixw7m.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509736/blog/ybb973hr7w6atstlcfo4.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509737/blog/xd5ugeloizhzejtocbsz.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509738/blog/nv4cvcnemfcnuuvjtdmn.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509738/blog/b8zpqyk71nqvgisjezxf.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509739/blog/oqawoc0vngffod4ze3cr.png">
<meta property="article:published_time" content="2018-04-15T16:31:09.000Z">
<meta property="article:modified_time" content="2023-03-11T05:02:28.494Z">
<meta property="article:author" content="xiaohai">
<meta property="article:tag" content="计算机视觉">
<meta property="article:tag" content="CS131">
<meta property="article:tag" content="边缘检测">
<meta property="article:tag" content="霍夫变换">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509731/blog/qcoewrt08vrfd6g6kcre.png">


<link rel="canonical" href="https://shenxiaohai.me/cs131-homework2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://shenxiaohai.me/cs131-homework2/","path":"cs131-homework2/","title":"CS131, Homewrok2, Edges-Smart Car Lane Detection"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CS131, Homewrok2, Edges-Smart Car Lane Detection | SHEN's DevNotes</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YDT7F4NZP6"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-YDT7F4NZP6","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="SHEN's DevNotes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SHEN's DevNotes</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习笔记，编程技巧，效率工具</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">131</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">74</span></a></li><li class="menu-item menu-item-碎碎念-|-memos"><a href="https://memos.shenxiaohai.me/" rel="section" target="_blank"><i class="fa fa-file-pen fa-fw"></i>碎碎念 | Memos</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Homework-2"><span class="nav-text">Homework 2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-1-Canny-Edge-Detector-85-points"><span class="nav-text">Part 1: Canny Edge Detector (85 points)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Smoothing-10-points"><span class="nav-text">1.1 Smoothing (10 points)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Implementation-5-points"><span class="nav-text">Implementation (5 points)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Question-5-points"><span class="nav-text">Question (5 points)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Finding-gradients-15-points"><span class="nav-text">1.2 Finding gradients (15 points)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Implementation-5-points-1"><span class="nav-text">Implementation (5 points)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Question-5-points-1"><span class="nav-text">Question (5 points)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Implementation-5-points-2"><span class="nav-text">Implementation (5 points)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Non-maximum-suppression-15-points"><span class="nav-text">1.3 Non-maximum suppression (15 points)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Double-Thresholding-20-points"><span class="nav-text">1.4 Double Thresholding (20 points)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Edge-tracking-15-points"><span class="nav-text">1.5 Edge tracking (15 points)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-Canny-edge-detector"><span class="nav-text">1.6 Canny edge detector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-Question-10-points"><span class="nav-text">1.7 Question (10 points)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Extra-Credit-Optimizing-Edge-Detector"><span class="nav-text">Extra Credit: Optimizing Edge Detector</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part2-Lane-Detection-15-points"><span class="nav-text">Part2: Lane Detection (15 points)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%A6%E9%81%93%E7%BA%BF%E6%A3%80%E6%B5%8B%E4%B8%89%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-text">车道线检测三步骤：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Edge-detection"><span class="nav-text">2.1 Edge detection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Extracting-region-of-interest-ROI"><span class="nav-text">2.2 Extracting region of interest (ROI)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Fitting-lines-using-Hough-transform-15-points"><span class="nav-text">2.3 Fitting lines using Hough transform (15 points)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%A3%E6%A1%88"><span class="nav-text">代码档案</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaohai</p>
  <div class="site-description" itemprop="description">我在这个技术博客中分享学习笔记，提供实用技巧和工具资源。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">131</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/veraposeidon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;veraposeidon" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/HiYoake" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;HiYoake" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shenxiaohai.me/cs131-homework2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaohai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHEN's DevNotes">
      <meta itemprop="description" content="我在这个技术博客中分享学习笔记，提供实用技巧和工具资源。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CS131, Homewrok2, Edges-Smart Car Lane Detection | SHEN's DevNotes">
      <meta itemprop="description" content="CS131 Computer Vision： Foundations and Applications，Homework2：Edges-Smart Car Lane Detection。<br> 重点在理解边缘检测，实现Canny算子，理解霍夫变换直线检测，以及利用Canny算子进行车道线检测。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CS131, Homewrok2, Edges-Smart Car Lane Detection
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-15 16:31:09" itemprop="dateCreated datePublished" datetime="2018-04-15T16:31:09Z">2018-04-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 05:02:28" itemprop="dateModified" datetime="2023-03-11T05:02:28Z">2023-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">CS131 Computer Vision： Foundations and Applications，Homework2：Edges-Smart Car Lane Detection。<br> 重点在理解边缘检测，实现Canny算子，理解霍夫变换直线检测，以及利用Canny算子进行车道线检测。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Homework-2"><a href="#Homework-2" class="headerlink" title="Homework 2"></a>Homework 2</h1><p><em>This notebook includes both coding and written questions. Please hand in this notebook file with all the outputs and your answers to the written questions.</em></p>
<p>这份作业的知识点包括边缘检测（实现Canny 边缘检测算子）和霍夫变换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Setup</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = (<span class="number">18.0</span>, <span class="number">12.0</span>) <span class="comment"># set default size of plots</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;image.interpolation&#x27;</span>] = <span class="string">&#x27;nearest&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;image.cmap&#x27;</span>] = <span class="string">&#x27;gray&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for auto-reloading extenrnal modules</span></span><br><span class="line">%load_ext autoreload</span><br><span class="line">%autoreload <span class="number">2</span></span><br></pre></td></tr></table></figure>

<pre><code>The autoreload extension is already loaded. To reload it, use:
  %reload_ext autoreload
</code></pre>
<h2 id="Part-1-Canny-Edge-Detector-85-points"><a href="#Part-1-Canny-Edge-Detector-85-points" class="headerlink" title="Part 1: Canny Edge Detector (85 points)"></a>Part 1: Canny Edge Detector (85 points)</h2><p>In this part, you are going to implment Canny edge detector. The Canny edge detection algorithm can be broken down in to five steps:</p>
<ol>
<li>Smoothing：<strong>平滑处理（去躁）</strong></li>
<li>Finding gradients：<strong>寻找梯度</strong></li>
<li>Non-maximum suppression：<strong>非极大值抑制</strong></li>
<li>Double thresholding：<strong>双阈值算法</strong></li>
<li>Edge tracking by hysteresis：<strong>滞后边缘追踪</strong></li>
</ol>
<h3 id="1-1-Smoothing-10-points"><a href="#1-1-Smoothing-10-points" class="headerlink" title="1.1 Smoothing (10 points)"></a>1.1 Smoothing (10 points)</h3><h4 id="Implementation-5-points"><a href="#Implementation-5-points" class="headerlink" title="Implementation (5 points)"></a>Implementation (5 points)</h4><p>We first smooth the input image by convolving it with a Gaussian kernel. The equation for a Gaussian kernel of size $(2k+1)\times(2k+1)$ is given by:</p>
<p>$$h_{ij}&#x3D;\frac{1}{2\pi\sigma^2}\exp{\Bigl(-\frac{(i-k)^2+(j-k)^2}{2\sigma^2}\Bigr)}, 0\leq i,j &lt; 2k+1$$</p>
<p>Implement <strong><code>gaussian_kernel</code></strong> in <code>edge.py</code> and run the code below.</p>
<p>代码实现高斯核的生成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> edge <span class="keyword">import</span> conv, gaussian_kernel</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define 3x3 Gaussian kernel with std = 1</span></span><br><span class="line">kernel = gaussian_kernel(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">kernel_test = np.array(</span><br><span class="line">    [[ <span class="number">0.05854983</span>, <span class="number">0.09653235</span>, <span class="number">0.05854983</span>],</span><br><span class="line">     [ <span class="number">0.09653235</span>, <span class="number">0.15915494</span>, <span class="number">0.09653235</span>],</span><br><span class="line">     [ <span class="number">0.05854983</span>, <span class="number">0.09653235</span>, <span class="number">0.05854983</span>]]</span><br><span class="line">)</span><br><span class="line"><span class="comment"># print(kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Test Gaussian kernel</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> np.allclose(kernel, kernel_test):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Incorrect values! Please check your implementation.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>需要先实现<code>edge.py</code>中的<code>conv</code>卷积函数，可以使用作业hw1中的<code>conv_nested</code>，<code>conv_fast</code>,<code>conv_faster</code>等函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Test with different kernel_size and sigma</span></span><br><span class="line">kernel_size = <span class="number">5</span></span><br><span class="line">sigma = <span class="number">1.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load image</span></span><br><span class="line">img = io.imread(<span class="string">&#x27;iguana.png&#x27;</span>, as_grey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define 5x5 Gaussian kernel with std = sigma</span></span><br><span class="line">kernel = gaussian_kernel(kernel_size, sigma)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convolve image with kernel to achieve smoothed effect</span></span><br><span class="line">smoothed = conv(img, kernel)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.title(<span class="string">&#x27;Original image&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(smoothed)</span><br><span class="line">plt.title(<span class="string">&#x27;Smoothed image&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509731/blog/qcoewrt08vrfd6g6kcre.png" alt="png"></p>
<h4 id="Question-5-points"><a href="#Question-5-points" class="headerlink" title="Question (5 points)"></a>Question (5 points)</h4><p>What is the effect of the kernel_size and sigma?</p>
<p>kernel_size和标准差 $\sigma$ 的影响？</p>
<p><strong>Your Answer:</strong> Write your solution in this markdown cell.</p>
<p>高斯滤波器用像素邻域的加权均值来代替该点的像素值，而每一邻域像素点权值是随该点与中心点的距离单调增减的，因为边缘是一种图像局部特征，如果平滑运算对离算子中心很远的像素点仍然有很大作用，则平滑运算会使图像失真。</p>
<p>高斯滤波器宽度(决定着平滑程度)是由参数σ表征的，而且σ和平滑程度的关系是非常简单的．σ越大，高斯滤波器的频带就越宽，平滑程度就越好．通过调节平滑程度参数σ，可在图像特征过分模糊(过平滑)与平滑图像中由于噪声和细纹理所引起的过多的不希望突变量(欠平滑)之间取得折衷。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013007900/article/details/78181249">高斯噪声与高斯滤波</a></p>
<h3 id="1-2-Finding-gradients-15-points"><a href="#1-2-Finding-gradients-15-points" class="headerlink" title="1.2 Finding gradients (15 points)"></a>1.2 Finding gradients (15 points)</h3><p>The gradient of a 2D scalar function $I:\mathbb{R}^2\rightarrow{\mathbb{R}}$ in Cartesian coordinate is defined by:</p>
<p>$$\nabla{I(x,y)}&#x3D;\bigl[\frac{\partial{I}}{\partial{x}},\frac{\partial{I}}{\partial{y}}\bigr],$$</p>
<p>where</p>
<p>$$<br>\frac{\partial{I(x,y)}}{\partial{x}}&#x3D;\lim_{\Delta{x}\to{0}}\frac{I(x+\Delta{x},y)-I(x,y)}{\Delta{x}} \<br>\frac{\partial{I(x,y)}}{\partial{y}}&#x3D;\lim_{\Delta{y}\to{0}}\frac{I(x,y+\Delta{y})-I(x,y)}{\Delta{y}}.<br>$$</p>
<p>In case of images, we can approximate the partial derivatives by taking differences at one pixel intervals:</p>
<p>$$<br>\frac{\partial{I(x,y)}}{\partial{x}}\approx{\frac{I(x+1,y)-I(x-1,y)}{2}} \<br>\frac{\partial{I(x,y)}}{\partial{y}}\approx{\frac{I(x,y+1)-I(x,y-1)}{2}}<br>$$</p>
<p>Note that the partial derivatives can be computed by convolving the image $I$ with some appropriate kernels $D_x$ and $D_y$:</p>
 
$$
\frac{\partial{I}}{\partial{x}}\approx{I*D_x}=G_x \\
\frac{\partial{I}}{\partial{y}}\approx{I*D_y}=G_y
$$


<h4 id="Implementation-5-points-1"><a href="#Implementation-5-points-1" class="headerlink" title="Implementation (5 points)"></a>Implementation (5 points)</h4><p>Find the kernels $D_x$ and $D_y$ and implement <strong><code>partial_x</code></strong> and <strong><code>partial_y</code></strong> using <code>conv</code> defined in <code>edge.py</code>.</p>
<p><em>-Hint: Remeber that convolution flips the kernel.</em></p>
<p>实现<code>edge.py</code>中的<code>partial_x</code>和<code>partial_y</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> edge <span class="keyword">import</span> partial_x, partial_y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Test input</span></span><br><span class="line">I = np.array(</span><br><span class="line">    [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected outputs</span></span><br><span class="line">I_x_test = np.array(</span><br><span class="line">    [[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [ <span class="number">0.5</span>, <span class="number">0</span>, -<span class="number">0.5</span>],</span><br><span class="line">     [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">I_y_test = np.array(</span><br><span class="line">    [[ <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>],</span><br><span class="line">     [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [ <span class="number">0</span>, -<span class="number">0.5</span>, <span class="number">0</span>]]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute partial derivatives</span></span><br><span class="line">I_x = partial_x(I)</span><br><span class="line">I_y = partial_y(I)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Test correctness of partial_x and partial_y</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> np.<span class="built_in">all</span>(I_x == I_x_test):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;partial_x incorrect&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> np.<span class="built_in">all</span>(I_y == I_y_test):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;partial_y incorrect&#x27;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compute partial derivatives of smoothed image</span></span><br><span class="line">Gx = partial_x(smoothed)</span><br><span class="line">Gy = partial_y(smoothed)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.imshow(Gx)</span><br><span class="line">plt.title(<span class="string">&#x27;Derivative in x direction&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(Gy)</span><br><span class="line">plt.title(<span class="string">&#x27;Derivative in y direction&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509731/blog/t2pkuuw45eiry6h6kpjc.png" alt="png"></p>
<h4 id="Question-5-points-1"><a href="#Question-5-points-1" class="headerlink" title="Question (5 points)"></a>Question (5 points)</h4><p>What is the reason for performing smoothing prior to computing the gradients?</p>
<p>梯度计算前为何要进行平滑滤波？</p>
<p><strong>Your Answer:</strong> Write your solution in this markdown cell.</p>
<p><strong>答</strong><br>平滑是为了去噪，噪声会使得计算梯度时得到幅度较大的异常值。</p>
<h4 id="Implementation-5-points-2"><a href="#Implementation-5-points-2" class="headerlink" title="Implementation (5 points)"></a>Implementation (5 points)</h4><p>Now, we can compute the magnitude and direction of gradient with the two partial derivatives:</p>
<p>$$<br>G &#x3D; \sqrt{G_{x}^{2}+G_{y}^{2}} \<br>\Theta &#x3D; arctan\bigl(\frac{G_{y}}{G_{x}}\bigr)<br>$$</p>
<p>Implement <strong><code>gradient</code></strong> in <code>edge.py</code> which takes in an image and outputs $G$ and $\Theta$.</p>
<p><em>-Hint: Use np.arctan2 to compute $\Theta$.</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> edge <span class="keyword">import</span> gradient</span><br><span class="line"></span><br><span class="line">G, theta = gradient(smoothed)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> np.<span class="built_in">all</span>(G &gt;= <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Magnitude of gradients should be non-negative.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> np.<span class="built_in">all</span>((theta &gt;= <span class="number">0</span>) * (theta &lt; <span class="number">360</span>)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Direction of gradients should be in range 0 &lt;= theta &lt; 360&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(G)</span><br><span class="line">plt.title(<span class="string">&#x27;Gradient magnitude&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509732/blog/ooxa8ytiuyva9uqyy0jy.png" alt="png"></p>
<h3 id="1-3-Non-maximum-suppression-15-points"><a href="#1-3-Non-maximum-suppression-15-points" class="headerlink" title="1.3 Non-maximum suppression (15 points)"></a>1.3 Non-maximum suppression (15 points)</h3><p>You should be able to note that the edges extracted from the gradient of the smoothed image is quite thick and blurry. The purpose of this step is to convert the “blurred” edges into “sharp” edges. Basically, this is done by preserving all local maxima in the gradient image and discarding everything else. The algorithm is for each pixel (x,y) in the gradient image:</p>
<ol>
<li><p>Round the gradient direction $\Theta[y,x]$ to the nearest 45 degrees, corresponding to the use of an 8-connected neighbourhood.</p>
</li>
<li><p>Compare the edge strength of the current pixel with the edge strength of the pixel in the positive and negative gradient direction. For example, if the gradient direction is south (theta&#x3D;90), compare with the pixels to the north and south.</p>
</li>
<li><p>If the edge strength of the current pixel is the largest; preserve the value of the edge strength. If not, suppress (i.e. remove) the value.</p>
</li>
</ol>
<p>Implement <strong><code>non_maximum_suppression</code></strong> in <code>edge.py</code></p>
<p><strong>非极大值抑制属于一种边缘细化的方法，梯度大的位置有可能为边缘，在这些位置沿着梯度方向，找到像素点的局部最大值，并将其非最大值抑制。</strong></p>
<p><strong>形象的说就是一条粗粗的区域都根据梯度强度判断成了边缘，但目标只需要一条细细的边，这个时候就找区域内的最大的那条作为边（注意是沿着梯度方向），其他的或抛弃或作为备选区域</strong></p>
<p><strong>步骤</strong></p>
<ol>
<li>在0,45,90,135四个梯度方向上对8-邻接像素进行判断，</li>
<li>直接比较梯度方向上的相邻的两个像素，</li>
<li>如果当前像素强度是最大，则保留；否则，则抑制它（变为零）。</li>
</ol>
<p><strong>备注</strong></p>
<p>当然这种做法其实是简化版本的，虽然Canny的论文上是这么写的，但是后来也有提出，梯度肯定不止这四个，针对别的梯度方向的比较，使用插值等方法来进行非极大值抑制。</p>
<p>可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kezunhai/article/details/11620357">Canny算子中的非极大值抑制（Non-Maximum Suppression）分析</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> edge <span class="keyword">import</span> non_maximum_suppression</span><br><span class="line"></span><br><span class="line"><span class="comment"># Test input</span></span><br><span class="line">g = np.array(</span><br><span class="line">    [[<span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>],</span><br><span class="line">     [<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.7</span>],</span><br><span class="line">     [<span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>]]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out non-maximum suppressed output</span></span><br><span class="line"><span class="comment"># varying theta</span></span><br><span class="line"><span class="keyword">for</span> angle <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">180</span>, <span class="number">45</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Thetas:&#x27;</span>, angle)</span><br><span class="line">    t = np.ones((<span class="number">3</span>, <span class="number">3</span>)) * angle <span class="comment"># Initialize theta</span></span><br><span class="line">    <span class="built_in">print</span>(non_maximum_suppression(g, t))</span><br></pre></td></tr></table></figure>

<pre><code>Thetas: 0
[[0.  0.  0.6]
 [0.  0.  0.7]
 [0.  0.  0.6]]
Thetas: 45
[[0.4 0.5 0.6]
 [0.  0.  0.7]
 [0.  0.  0.6]]
Thetas: 90
[[0.4 0.5 0. ]
 [0.  0.5 0.7]
 [0.4 0.5 0. ]]
Thetas: 135
[[0.  0.  0.6]
 [0.  0.  0.7]
 [0.4 0.5 0.6]]
</code></pre>
<p>目测是正确的。在每个梯度方向上保留最大的那个值，其他的值置为零。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nms = non_maximum_suppression(G, theta)</span><br><span class="line">plt.imshow(nms)</span><br><span class="line">plt.title(<span class="string">&#x27;Non-maximum suppressed&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509732/blog/ckl03zx9rnbfkliaws6i.png" alt="png"></p>
<h3 id="1-4-Double-Thresholding-20-points"><a href="#1-4-Double-Thresholding-20-points" class="headerlink" title="1.4 Double Thresholding (20 points)"></a>1.4 Double Thresholding (20 points)</h3><p>The edge-pixels remaining after the non-maximum suppression step are (still) marked with their strength pixel-by-pixel. Many of these will probably be true edges in the image, but some may be caused by noise or color variations, for instance, due to rough surfaces. The simplest way to discern between these would be to use a threshold, so that only edges stronger that a certain value would be preserved. The Canny edge detection algorithm uses double thresholding. Edge pixels stronger than the high threshold are marked as strong; edge pixels weaker than the low threshold are suppressed and edge pixels between the two thresholds are marked as weak.</p>
<p>Implement <strong><code>double_thresholding</code></strong> in <code>edge.py</code></p>
<p>双阀值方法，设置一个maxval，以及minval，梯度大于maxval则为强边缘，梯度值介于maxval与minval则为弱边缘点，小于minval为抑制点。</p>
<p>双阈值的结果在第五步可以用来作为边缘追踪的依据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> edge <span class="keyword">import</span> double_thresholding</span><br><span class="line"></span><br><span class="line">low_threshold = <span class="number">0.02</span></span><br><span class="line">high_threshold = <span class="number">0.03</span></span><br><span class="line"></span><br><span class="line">strong_edges, weak_edges = double_thresholding(nms, high_threshold, low_threshold)</span><br><span class="line"><span class="keyword">assert</span>(np.<span class="built_in">sum</span>(strong_edges &amp; weak_edges) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">edges=strong_edges * <span class="number">1.0</span> + weak_edges * <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.imshow(strong_edges)</span><br><span class="line">plt.title(<span class="string">&#x27;Strong Edges&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(edges)</span><br><span class="line">plt.title(<span class="string">&#x27;Strong+Weak Edges&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509733/blog/czpzsnkoxktmctyxfckc.png" alt="png"></p>
<h3 id="1-5-Edge-tracking-15-points"><a href="#1-5-Edge-tracking-15-points" class="headerlink" title="1.5 Edge tracking (15 points)"></a>1.5 Edge tracking (15 points)</h3><p>Strong edges are interpreted as “certain edges”, and can immediately be included in the final edge image. Weak edges are included if and only if they are connected to strong edges. The logic is of course that noise and other small variations are unlikely to result in a strong edge (with proper adjustment of the threshold levels). Thus strong edges will (almost) only be due to true edges in the original image. The weak edges can either be due to true edges or noise&#x2F;color variations. The latter type will probably be distributed in dependently of edges on the entire image, and thus only a small amount will be located adjacent to strong edges. Weak edges due to true edges are much more likely to be connected directly to strong edges.</p>
<p>Implement <strong><code>link_edges</code></strong> in <code>edge.py</code></p>
<p>由于边缘是连续的，因此可以认为弱边缘如果为真实边缘则和强边缘是联通的，可由此判断其是否为真实边缘。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> edge <span class="keyword">import</span> get_neighbors, link_edges</span><br><span class="line"></span><br><span class="line">test_strong = np.array(</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">test_weak = np.array(</span><br><span class="line">    [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">test_linked = link_edges(test_strong, test_weak)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(test_strong)</span><br><span class="line">plt.title(<span class="string">&#x27;Strong edges&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">plt.imshow(test_weak)</span><br><span class="line">plt.title(<span class="string">&#x27;Weak edges&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">plt.imshow(test_linked)</span><br><span class="line">plt.title(<span class="string">&#x27;Linked edges&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509733/blog/euk2k1v4efzm2f5pmg84.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">edges = link_edges(strong_edges, weak_edges)</span><br><span class="line"></span><br><span class="line">plt.imshow(edges)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509734/blog/sfond4qmlgla42tmwpxb.png" alt="png"></p>
<h3 id="1-6-Canny-edge-detector"><a href="#1-6-Canny-edge-detector" class="headerlink" title="1.6 Canny edge detector"></a>1.6 Canny edge detector</h3><p>Implement <strong><code>canny</code></strong> in <code>edge.py</code> using the functions you have implemented so far. Test edge detector with different parameters.</p>
<p>Here is an example of the output:</p>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509735/blog/uu1tz7suftbbdq90nxrh.png" alt="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509735/blog/uu1tz7suftbbdq90nxrh.png"></p>
<p>将上面的五个步骤拼成一个Canny边缘检测算子。</p>
<ol>
<li>Smoothing：<strong>平滑处理（去躁）</strong></li>
<li>Finding gradients：<strong>寻找梯度</strong></li>
<li>Non-maximum suppression：<strong>非极大值抑制</strong></li>
<li>Double thresholding：<strong>双阈值算法</strong></li>
<li>Edge tracking by hysteresis：<strong>滞后边缘追踪</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> edge <span class="keyword">import</span> canny</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load image</span></span><br><span class="line">img = io.imread(<span class="string">&#x27;iguana.png&#x27;</span>, as_grey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run Canny edge detector</span></span><br><span class="line">edges = canny(img, kernel_size=<span class="number">5</span>, sigma=<span class="number">1.4</span>, high=<span class="number">0.04</span>, low=<span class="number">0.02</span>)</span><br><span class="line"><span class="built_in">print</span> (edges.shape)</span><br><span class="line">plt.imshow(edges)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>(310, 433)
</code></pre>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509735/blog/hawjmbzakcatysbx4lhd.png" alt="png"></p>
<p>怎么调参也调不出合理的效果，应该是此时非极大值抑制，抑制的有些过分了。</p>
<h3 id="1-7-Question-10-points"><a href="#1-7-Question-10-points" class="headerlink" title="1.7 Question (10 points)"></a>1.7 Question (10 points)</h3><p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509736/blog/jsujhdnt74k9fkrixw7m.png" alt="img"><br><strong>(a)</strong> Suppose that the Canny edge detector successfully detects an edge in an image. The edge (see the figure above) is then rotated by θ, where the relationship between a point on the original edge $(x, y)$ and a point on the rotated edge $(x’, y’)$ is defined as</p>
<p>$$<br>x’&#x3D;x\cos{\theta}\<br>y’&#x3D;x\sin{\theta}<br>$$</p>
<p>Will the rotated edge be detected using the same Canny edge detector? Provide either a mathematical proof or a counter example.</p>
<p><em>-Hint: The detection of an edge by the Canny edge detector depends only on the magnitude of its derivative. The derivative at point (x, y) is determined by its components along the x and y directions. Think about how these magnitudes have changed because of the rotation.</em></p>
<p><strong>Your Answer:</strong> Write your solution in this markdown cell.</p>
 
$$ Mag_{origin} = \sqrt {{dx}^2 + {dy}^2} = |dx| $$
$$ Mag_{rotate} = \sqrt {{dx^{'}}^{2} + {dy^{'}}^{2}} = \sqrt {({dx\cos \theta}) ^2+ ({dx\sin\theta})^2} = |dx|$$

 

<p>幅度没变，所以边缘检测不变。</p>
<p>参考网上博客写法，此处我也没弄懂。</p>
<p><strong>(b)</strong> After running the Canny edge detector on an image, you notice that long edges are broken into short segments separated by gaps. In addition, some spurious edges appear. For each of the two thresholds (low and high) used in hysteresis thresholding, explain how you would adjust the threshold (up or down) to address both problems. Assume that a setting exists for the two thresholds that produces the desired result. Briefly explain your answer.</p>
<p><strong>Your Answer:</strong> Write your solution in this markdown cell.</p>
<p>调参方法：</p>
<ul>
<li>如果长直线被断成小段，说明weak_edges的阈值太大，weak_edges的数量较少，此时应当调低weak_edges的阈值。</li>
<li>如果spurious (伪直线)出现，说明strong_edges的阈值太小，strong_edges的数量较多，此时应当调高strong_edges的阈值。</li>
</ul>
<h3 id="Extra-Credit-Optimizing-Edge-Detector"><a href="#Extra-Credit-Optimizing-Edge-Detector" class="headerlink" title="Extra Credit: Optimizing Edge Detector"></a>Extra Credit: Optimizing Edge Detector</h3><p>One way of evaluating an edge detector is to compare detected edges with manually specified ground truth edges. Here, we use precision, recall and F1 score as evaluation metrics. We provide you 40 images of objects with ground truth edge annotations. Run the code below to compute precision, recall and F1 score over the entire set of images. Then, tweak the parameters of the Canny edge detector to get as high F1 score as possible. You should be able to achieve F1 score higher than 0.31 by carefully setting the parameters.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define parameters to test</span></span><br><span class="line">sigmas = [<span class="number">1.6</span>, <span class="number">1.7</span>, <span class="number">1.8</span>, <span class="number">1.9</span>, <span class="number">2.0</span>]</span><br><span class="line">highs = [<span class="number">0.04</span>, <span class="number">0.05</span>, <span class="number">0.06</span>]</span><br><span class="line">lows = [<span class="number">0.015</span>, <span class="number">0.02</span>, <span class="number">0.025</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sigma, high, low <span class="keyword">in</span> product(sigmas, highs, lows):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sigma=&#123;&#125;, high=&#123;&#125;, low=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(sigma, high, low))</span><br><span class="line">    n_detected = <span class="number">0.0</span></span><br><span class="line">    n_gt = <span class="number">0.0</span></span><br><span class="line">    n_correct = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> img_file <span class="keyword">in</span> listdir(<span class="string">&#x27;images/objects&#x27;</span>):</span><br><span class="line">        img = io.imread(<span class="string">&#x27;images/objects/&#x27;</span>+img_file, as_grey=<span class="literal">True</span>)</span><br><span class="line">        gt = io.imread(<span class="string">&#x27;images/gt/&#x27;</span>+img_file+<span class="string">&#x27;.gtf.pgm&#x27;</span>, as_grey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        mask = (gt != <span class="number">5</span>) <span class="comment"># &#x27;don&#x27;t&#x27; care region</span></span><br><span class="line">        gt = (gt == <span class="number">0</span>) <span class="comment"># binary image of GT edges</span></span><br><span class="line"></span><br><span class="line">        edges = canny(img, kernel_size=<span class="number">5</span>, sigma=sigma, high=high, low=low)</span><br><span class="line">        edges = edges * mask</span><br><span class="line"></span><br><span class="line">        n_detected += np.<span class="built_in">sum</span>(edges)</span><br><span class="line">        n_gt += np.<span class="built_in">sum</span>(gt)</span><br><span class="line">        n_correct += np.<span class="built_in">sum</span>(edges * gt)</span><br><span class="line"></span><br><span class="line">    p_total = n_correct / n_detected</span><br><span class="line">    r_total = n_correct / n_gt</span><br><span class="line">    f1 = <span class="number">2</span> * (p_total * r_total) / (p_total + r_total)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Total precision=&#123;:.4f&#125;, Total recall=&#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(p_total, r_total))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;F1 score=&#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(f1))</span><br></pre></td></tr></table></figure>

<h2 id="Part2-Lane-Detection-15-points"><a href="#Part2-Lane-Detection-15-points" class="headerlink" title="Part2: Lane Detection (15 points)"></a>Part2: Lane Detection (15 points)</h2><p>In this section we will implement a simple lane detection application using Canny edge detector and Hough transform.<br>Here are some example images of how your final lane detector will look like.<br><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509736/blog/ybb973hr7w6atstlcfo4.png" alt="lane1"><br><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509737/blog/xd5ugeloizhzejtocbsz.png" alt="lane2"></p>
<p>The algorithm can broken down into the following steps:</p>
<ol>
<li>Detect edges using the Canny edge detector.</li>
<li>Extract the edges in the region of interest (a triangle covering the bottom corners and the center of the image).</li>
<li>Run Hough transform to detect lanes.</li>
</ol>
<h3 id="车道线检测三步骤："><a href="#车道线检测三步骤：" class="headerlink" title="车道线检测三步骤："></a>车道线检测三步骤：</h3><ol>
<li>使用Canny边缘检测器检测边缘</li>
<li>提取图像中的感兴趣区域（图像中心的三角形区域）</li>
<li>使用霍夫变换检测车道线</li>
</ol>
<h3 id="2-1-Edge-detection"><a href="#2-1-Edge-detection" class="headerlink" title="2.1 Edge detection"></a>2.1 Edge detection</h3><p>Lanes on the roads are usually thin and long lines with bright colors. Our edge detection algorithm by itself should be able to find the lanes pretty well. Run the code cell below to load the example image and detect edges from the image.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> edge <span class="keyword">import</span> canny</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load image</span></span><br><span class="line">img = io.imread(<span class="string">&#x27;road.jpg&#x27;</span>, as_grey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run Canny edge detector</span></span><br><span class="line">edges = canny(img, kernel_size=<span class="number">5</span>, sigma=<span class="number">1.4</span>, high=<span class="number">0.03</span>, low=<span class="number">0.008</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.imshow(edges)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Edges&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509738/blog/nv4cvcnemfcnuuvjtdmn.png" alt="png"></p>
<h3 id="2-2-Extracting-region-of-interest-ROI"><a href="#2-2-Extracting-region-of-interest-ROI" class="headerlink" title="2.2 Extracting region of interest (ROI)"></a>2.2 Extracting region of interest (ROI)</h3><p>We can see that the Canny edge detector could find the edges of the lanes. However, we can also see that there are edges of other objects that we are not interested in. Given the position and orientation of the camera, we know that the lanes will be located in the lower half of the image. The code below defines a binary mask for the ROI and extract the edges within the region.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">H, W = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate mask for ROI (Region of Interest)</span></span><br><span class="line">mask = np.zeros((H, W))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(W):</span><br><span class="line">        <span class="keyword">if</span> i &gt; (H / W) * j <span class="keyword">and</span> i &gt; -(H / W) * j + H:</span><br><span class="line">            mask[i, j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract edges in ROI</span></span><br><span class="line">roi = edges * mask</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.imshow(mask)</span><br><span class="line">plt.title(<span class="string">&#x27;Mask&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(roi)</span><br><span class="line">plt.title(<span class="string">&#x27;Edges in ROI&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509738/blog/b8zpqyk71nqvgisjezxf.png" alt="png"></p>
<h3 id="2-3-Fitting-lines-using-Hough-transform-15-points"><a href="#2-3-Fitting-lines-using-Hough-transform-15-points" class="headerlink" title="2.3 Fitting lines using Hough transform (15 points)"></a>2.3 Fitting lines using Hough transform (15 points)</h3><p>The output from the edge detector is still a collection of connected points. However, it would be more natural to represent a lane as a line parameterized as $y &#x3D; ax + b$, with a slope $a$ and y-intercept $b$. We will use Hough transform to find parameterized lines that represent the detected edges.</p>
<p>In general, a straight line $y &#x3D; ax + b$ can be represented as a point $(a, b)$ in the parameter space. However, this cannot represent vertical lines as the slope parameter will be unbounded. Alternatively, we parameterize a line using $\theta\in{[-\pi, \pi]}$ and $\rho\in{\mathbb{R}}$ as follows:</p>
<p>$$<br>\rho &#x3D; x\cdot{cos\theta} + y\cdot{sin\theta}<br>$$</p>
<p>Using this parameterization, we can map everypoint in $xy$-space to a sine-like line in $\theta\rho$-space (or Hough space). We then accumulate the parameterized points in the Hough space and choose points (in Hough space) with highest accumulated values. A point in Hough space then can be transformed back into a line in $xy$-space.</p>
<p><em>See <a target="_blank" rel="noopener" href="http://web.ipac.caltech.edu/staff/fmasci/home/astro_refs/HoughTrans_lines_09.pdf">notes</a> on Hough transform.</em></p>
<p>Implement <strong><code>hough_transform</code></strong> in <code>edge.py</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> edge <span class="keyword">import</span> hough_transform</span><br><span class="line"></span><br><span class="line"><span class="comment"># Perform Hough transform on the ROI</span></span><br><span class="line">acc, rhos, thetas = hough_transform(roi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Coordinates for right lane</span></span><br><span class="line">xs_right = []</span><br><span class="line">ys_right = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># Coordinates for left lane</span></span><br><span class="line">xs_left = []</span><br><span class="line">ys_left = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    idx = np.argmax(acc)</span><br><span class="line">    r_idx = idx // acc.shape[<span class="number">1</span>]</span><br><span class="line">    t_idx = idx % acc.shape[<span class="number">1</span>]</span><br><span class="line">    acc[r_idx, t_idx] = <span class="number">0</span> <span class="comment"># Zero out the max value in accumulator</span></span><br><span class="line"></span><br><span class="line">    rho = rhos[r_idx]</span><br><span class="line">    theta = thetas[t_idx]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Transform a point in Hough space to a line in xy-space.</span></span><br><span class="line">    a = - (np.cos(theta)/np.sin(theta)) <span class="comment"># slope of the line</span></span><br><span class="line">    b = (rho/np.sin(theta)) <span class="comment"># y-intersect of the line</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Break if both right and left lanes are detected</span></span><br><span class="line">    <span class="keyword">if</span> xs_right <span class="keyword">and</span> xs_left:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span>: <span class="comment"># Left lane</span></span><br><span class="line">        <span class="keyword">if</span> xs_left:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        xs = xs_left</span><br><span class="line">        ys = ys_left</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># Right Lane</span></span><br><span class="line">        <span class="keyword">if</span> xs_right:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        xs = xs_right</span><br><span class="line">        ys = ys_right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.shape[<span class="number">1</span>]):</span><br><span class="line">        y = a * x + b</span><br><span class="line">        <span class="keyword">if</span> y &gt; img.shape[<span class="number">0</span>] * <span class="number">0.6</span> <span class="keyword">and</span> y &lt; img.shape[<span class="number">0</span>]:</span><br><span class="line">            xs.append(x)</span><br><span class="line">            ys.append(<span class="built_in">int</span>(<span class="built_in">round</span>(y)))</span><br><span class="line"></span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.plot(xs_left, ys_left, linewidth=<span class="number">5.0</span>)</span><br><span class="line">plt.plot(xs_right, ys_right, linewidth=<span class="number">5.0</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509739/blog/oqawoc0vngffod4ze3cr.png" alt="png"></p>
<p><strong>之所以只检测出一条直线，是因为上面的边缘检测部分不是很完美，尤其是左边车道线的边缘检测出现了问题，才会导致左边车道线做霍夫变换也得不到理想的结果。</strong></p>
<h1 id="代码档案"><a href="#代码档案" class="headerlink" title="代码档案"></a>代码档案</h1><p><a target="_blank" rel="noopener" href="https://github.com/StanfordVL/CS131_release/tree/master/hw2_release">官方Repo作业材料</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/veraposeidon/CS131_Assignments/tree/master/hw2_release">个人Repo作业存档</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>xiaohai
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://shenxiaohai.me/cs131-homework2/" title="CS131, Homewrok2, Edges-Smart Car Lane Detection">https://shenxiaohai.me/cs131-homework2/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" rel="tag"><i class="fa fa-tag"></i> 计算机视觉</a>
              <a href="/tags/CS131/" rel="tag"><i class="fa fa-tag"></i> CS131</a>
              <a href="/tags/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/" rel="tag"><i class="fa fa-tag"></i> 边缘检测</a>
              <a href="/tags/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/" rel="tag"><i class="fa fa-tag"></i> 霍夫变换</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/cs131-homework1/" rel="prev" title="CS131, Homewrok1, Filters-Instagram">
                  <i class="fa fa-chevron-left"></i> CS131, Homewrok1, Filters-Instagram
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/PCL-Modules/" rel="next" title="PCL模块介绍">
                  PCL模块介绍 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments"><div id="twikoo-comments"></div></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-laptop"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaohai</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/veraposeidon" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://shenxiaohai.me/cs131-homework2/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="twikoo" type="application/json">{"enable":true,"visitor":false,"envId":"https://twikoo-comment.shenxiaohai.me/","el":"#twikoo-comments"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.twikoo.el)
    .then(() => NexT.utils.getScript(
      CONFIG.twikoo.jsUrl || 'https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js',
      { condition: window.twikoo }
    ))
    .then(() => {
      twikoo.init(CONFIG.twikoo);
    });
});
</script>
<style>
.post-block, .comments {
  overflow: visible;
}
.tk-owo-emotion {
  display: inline-block;
}
</style>

</body>
</html>
