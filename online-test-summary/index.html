<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.webp" color="#222">
  <meta name="google-site-verification" content="Cj9oDgXxdJe6MoA_lEUQ2rmOouwJeTm5uJNqjhOv8Ng">
  <meta name="msvalidate.01" content="E5D0AA8F5E012DFD9C5F3954DF8283B1">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenxiaohai.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"twikoo","storage":true,"lazyload":false,"nav":null,"activeClass":"twikoo"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="失败不是什么丢人的事情，从失败中全无收获才是。">
<meta property="og:type" content="article">
<meta property="og:title" content="总结总结笔试不会的题">
<meta property="og:url" content="https://shenxiaohai.me/online-test-summary/index.html">
<meta property="og:site_name" content="SHEN&#39;s DevNotes">
<meta property="og:description" content="失败不是什么丢人的事情，从失败中全无收获才是。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509811/blog/h9u1i0fckxh938ud1goj.webp">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509811/blog/hhh2hj1fp9xtz70djk5r.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509812/blog/vnjjtb5qpypkrpzewbic.jpg">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509813/blog/i7b20ngluerocikmstcn.jpg">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509813/blog/vqxppvo38dkqqvgchxq3.jpg">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509814/blog/jggacsldcdfjqd1s9iki.jpg">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509814/blog/drt4adqx0ddzqzmcmijn.jpg">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509815/blog/aqx8kewuxidhcokmcwkw.jpg">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509816/blog/satn1uahf2iiyxpzdoxl.jpg">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509816/blog/msoulmxqwybky9zquxwi.jpg">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509817/blog/fbl93v07e0tdxewafqbm.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509817/blog/jl05hklsjpemtfqdngm8.jpg">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509818/blog/zcqqnntqc89udtwdx2cx.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509819/blog/vbvkj0yqrwnqr8cypqt5.png">
<meta property="article:published_time" content="2019-08-17T10:54:51.000Z">
<meta property="article:modified_time" content="2023-03-11T05:02:28.690Z">
<meta property="article:author" content="xiaohai">
<meta property="article:tag" content="笔试">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509811/blog/h9u1i0fckxh938ud1goj.webp">


<link rel="canonical" href="https://shenxiaohai.me/online-test-summary/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://shenxiaohai.me/online-test-summary/","path":"online-test-summary/","title":"总结总结笔试不会的题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>总结总结笔试不会的题 | SHEN's DevNotes</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YDT7F4NZP6"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-YDT7F4NZP6","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="SHEN's DevNotes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SHEN's DevNotes</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习笔记，编程技巧，效率工具</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">131</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">74</span></a></li><li class="menu-item menu-item-碎碎念-|-memos"><a href="https://memos.shenxiaohai.me/" rel="section" target="_blank"><i class="fa fa-file-pen fa-fw"></i>碎碎念 | Memos</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text">程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-text">稳定性的意义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">单例模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL%E7%9B%B8%E5%85%B3"><span class="nav-text">STL相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-x2F-C-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">C&#x2F;C++关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">volatile 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">const 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-x2F-delete%E4%B8%8Emalloc-x2F-free%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">new&#x2F;delete与malloc&#x2F;free的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extern%E5%92%8Cexport"><span class="nav-text">extern和export</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explicit"><span class="nav-text">explicit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86try-catch-throw-finally"><span class="nav-text">异常处理try-catch-throw-finally</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">指针和引用的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB"><span class="nav-text">结构体与类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97"><span class="nav-text">C++类的大小计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%B2%E7%9F%A5String%E7%B1%BB%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%B6%E5%87%BD%E6%95%B0%E4%BD%93"><span class="nav-text">已知String类定义，如何实现其函数体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="nav-text">内存分配的形式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91"><span class="nav-text">编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">编译和连接的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%92%8CC%E5%85%BC%E5%AE%B9"><span class="nav-text">C++和C兼容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-text">基本特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">复制构造函数和赋值运算符的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-text">类成员的初始化顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BE%97%E7%9F%A5%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%9E%84%E9%80%A0%E6%88%90%E5%8A%9F%EF%BC%9F"><span class="nav-text">构造函数没有返回值，如何得知对象是否构造成功？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E7%A9%BA%E7%B1%BB%E9%BB%98%E8%AE%A4%E4%BA%A7%E7%94%9F%E5%93%AA%E4%BA%9B%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">C++中的空类默认产生哪些成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public%E3%80%81protected%E3%80%81private%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">public、protected、private的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%8F%AA%E8%83%BD%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E8%80%8C%E4%B8%8D%E8%83%BD%E7%94%A8%E8%B5%8B%E5%80%BC"><span class="nav-text">C++有哪些情况只能用初始化列表而不能用赋值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-text">什么是虚函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-text">虚函数的实现机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81"><span class="nav-text">C++如何实现多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">纯虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%A4%9A%E6%80%81%E7%A7%8D%E7%B1%BB"><span class="nav-text">C++多态种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-text">什么函数不能声明为虚函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%8A%8A%E6%AF%8F%E4%B8%AA%E5%87%BD%E6%95%B0%E9%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">是否可以把每个函数都声明为虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">C++中如何阻止一个类被实例化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8CTCP-x2F-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%AF%8F%E5%B1%82%E5%88%97%E4%B8%BE2%E4%B8%AA%E5%8D%8F%E8%AE%AE"><span class="nav-text">OSI七层模型和TCP&#x2F;IP四层模型，每层列举2个协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-x2F-IP"><span class="nav-text">TCP&#x2F;IP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E5%A4%B4%E5%92%8CTCP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E5%A4%B4"><span class="nav-text">UDP协议报头和TCP协议报头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-text">TCP保证可靠性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-responce-code"><span class="nav-text">HTTP responce code</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET-x2F-POST%E5%8C%BA%E5%88%AB"><span class="nav-text">GET&#x2F;POST区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8AHTTPS%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">HTTP和HTTPS的区别，以及HTTPS的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket%E5%92%8CSocket%E7%BC%96%E7%A8%8B"><span class="nav-text">Socket和Socket编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-x2F-O%E6%A8%A1%E5%9E%8B%EF%BC%88%E8%BD%AC%EF%BC%89"><span class="nav-text">I&#x2F;O模型（转）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="nav-text">数据传输方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket%E7%A8%8B%E5%BA%8F%E6%BC%94%E7%A4%BA"><span class="nav-text">Socket程序演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-text">参数、函数说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#socket-%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-text">socket()函数创建套接字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind-%E5%92%8Cconnect-%E5%87%BD%E6%95%B0"><span class="nav-text">bind()和connect()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#listen-%E5%92%8Caccept-%E5%87%BD%E6%95%B0"><span class="nav-text">listen()和accept()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6"><span class="nav-text">数据发送与接收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">迭代服务器和客户端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scoket%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">scoket缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="nav-text">阻塞模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%9A%84%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%A0%E8%BE%B9%E7%95%8C%E6%80%A7"><span class="nav-text">TCP的粘包问题和数据的无边界性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-text">TCP数据报结构和三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B"><span class="nav-text">TCP数据的传输过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-text">TCP四次握手断开连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket%E4%BC%98%E9%9B%85%E5%9C%B0%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E2%80%93shutdown"><span class="nav-text">socket优雅地断开连接–shutdown()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F-htons-%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%B0%8F%E7%AB%AF%E5%BA%8F"><span class="nav-text">socket网络字节序+htons()函数以及大端序小端序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8socket%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9F%9F%E5%90%8D"><span class="nav-text">在socket中使用域名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3UDP%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-text">理解UDP套接字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">进程与线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-text">线程同步的机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%88IPC-Inter-Process-Communication%EF%BC%89"><span class="nav-text">Linux进程间通信方式（IPC: Inter-Process Communication）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%88concurrency%EF%BC%89%E5%92%8C%E5%B9%B6%E8%A1%8C%EF%BC%88parallelism%EF%BC%89"><span class="nav-text">并发（concurrency）和并行（parallelism）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="nav-text">先来先服务和短作业优先</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">内存管理的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">分页和分段存储管理有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-text">首次适应算法-最佳适应算法-最坏适应算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD-FIFO%E3%80%81LRU%E3%80%81OPT%E4%B8%89%E7%A7%8D%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">缺页中断-FIFO、LRU、OPT三种置换算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3"><span class="nav-text">用户编程接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-text">静态链接和动态链接的不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E6%A0%B8%E5%BF%83%E6%80%81"><span class="nav-text">用户态和核心态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%A0%88%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88"><span class="nav-text">用户栈与内核栈</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="nav-text">数据库事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B"><span class="nav-text">举例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9A"><span class="nav-text">原子性：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-text">持久性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E9%9A%94%E7%A6%BB%E8%A1%8C"><span class="nav-text">原子性与隔离行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL"><span class="nav-text">SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">SQL查询语句执行顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%8F%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-SQL-Server"><span class="nav-text">脏读、幻读、不可重复读 + 事务隔离级别+SQL Server</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">隔离级别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-text">悲观锁和乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-text">公平锁与非公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E4%B8%8E%E6%8E%92%E5%AE%83%E9%94%81"><span class="nav-text">共享锁与排它锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%86%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86"><span class="nav-text">计算机视觉＆图像处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6"><span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86"><span class="nav-text">字节跳动面经整理</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaohai</p>
  <div class="site-description" itemprop="description">我在这个技术博客中分享学习笔记，提供实用技巧和工具资源。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">131</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/veraposeidon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;veraposeidon" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/HiYoake" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;HiYoake" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shenxiaohai.me/online-test-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaohai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHEN's DevNotes">
      <meta itemprop="description" content="我在这个技术博客中分享学习笔记，提供实用技巧和工具资源。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="总结总结笔试不会的题 | SHEN's DevNotes">
      <meta itemprop="description" content="失败不是什么丢人的事情，从失败中全无收获才是。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          总结总结笔试不会的题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-17 10:54:51" itemprop="dateCreated datePublished" datetime="2019-08-17T10:54:51Z">2019-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 05:02:28" itemprop="dateModified" datetime="2023-03-11T05:02:28Z">2023-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">找工作</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">失败不是什么丢人的事情，从失败中全无收获才是。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>非科班找工作，计算机基础问啥啥也不会啊，只能啃书啃视频，一样一样总结咯。</p>
<p>强烈推荐这份Git资料，作者非常良心。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></p>
<p>在线阅读更清爽：<a target="_blank" rel="noopener" href="https://cyc2018.github.io/CS-Notes/#/">https://cyc2018.github.io/CS-Notes/#/</a></p>
<h1 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/p/7674659.html">排序算法</a></h2><table>
<thead>
<tr>
<th>方法</th>
<th>平均</th>
<th>最坏</th>
<th>最好</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>插入排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^1&#x2F;3^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(nlogn)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<h3 id="稳定性的意义"><a href="#稳定性的意义" class="headerlink" title="稳定性的意义"></a>稳定性的意义</h3><p>1、如果只是简单的进行数字的排序，那么稳定性将毫无意义。<br>2、如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧将毫无意义（所谓的交换操作的开销已经算在算法的开销内了，如果嫌弃这种开销，不如换算法好了？）<br>3、如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。<br>4、除非要排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序。（当然，如果需求不需要保持初始的排序意义，那么使用稳定性算法依旧将毫无意义）。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>学习材料和推荐博文：<a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">23种设计模式全面解析（超级详细）</a></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>
<p><strong>定义</strong>：</p>
<ol>
<li>私有化它的构造函数，以防止外界创建单例类的对象</li>
<li>使用类的私有静态指针变量指向类的唯一实例</li>
<li>使用一个公有的静态方法获取该实例</li>
</ol>
<p><strong>懒汉版</strong>：单例实例在第一次被使用时才进行初始化，叫做延迟初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;	<span class="comment">// 私有静态指针</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;;	<span class="comment">// 私有化构造函数</span></span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lazy Singleton存在内存泄漏问题，解决办法：</p>
<ol>
<li>使用智能指针</li>
<li>使用静态的嵌套类对象</li>
</ol>
<h2 id="STL相关"><a href="#STL相关" class="headerlink" title="STL相关"></a>STL相关</h2><p>学习材料和推荐博文：<a target="_blank" rel="noopener" href="http://c.biancheng.net/stl/">STL教程：C++ STL快速入门（非常详细）</a></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>学习材料和推荐博文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/MoreWindows/article/details/7392749">秒杀多线程第一篇 多线程笔试面试题汇总</a></p>
<h2 id="C-x2F-C-关键字"><a href="#C-x2F-C-关键字" class="headerlink" title="C&#x2F;C++关键字"></a>C&#x2F;C++关键字</h2><h3 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h3><p>为应对编译器优化（release模式）出现的问题：当遇到多线程编程时，变量的值可能因为别的线程而改变，而寄存器的值不会相应改变，从而造成程序读取的值与实际的变量值不一致。举例来说，为了使读取变量时提高存储速度，编译器优化过程中把变量读到寄存器内，当以后再取时，直接从寄存器取；当变量在本线程改变时，变量值直接更新到寄存器。而当该变量被别的线程改变时，本线程相当于没有收到通知，造成信息不一致。</p>
<p>volatile是一个类型修饰符，用来修饰被不同线程访问和修改的变量。系统每次用到它的时候直接从对应的内存中提取，不走cache和寄存器。所以，volatile一般修饰多线程间被多个任务共享的变量和并行设备硬件寄存器等。</p>
<h3 id="const-的作用"><a href="#const-的作用" class="headerlink" title="const 的作用"></a>const 的作用</h3><ol>
<li>定义const常量</li>
<li>进行类型检查</li>
<li>定义意义确定的数字，比如const max&#x3D;0xFFFF. 不变则已一变俱变。</li>
<li>保护被修饰的对象，防止意外修改</li>
<li>提示进行函数重载</li>
<li>相比于#define，const更加节省内存空间</li>
<li>提高程序效率，编译器不为普通const常量分配存储空间，而是将他们存在符号表中，没有存储与读内存操作，可以提高使用效率。</li>
</ol>
<h3 id="new-x2F-delete与malloc-x2F-free的区别"><a href="#new-x2F-delete与malloc-x2F-free的区别" class="headerlink" title="new&#x2F;delete与malloc&#x2F;free的区别"></a>new&#x2F;delete与malloc&#x2F;free的区别</h3><ol>
<li>new能够自动计算需要分配的内存空间，而malloc需要手工计算字节数；</li>
<li>new与delete直接带具体类型的指针，malloc与free返回void类型的指针；</li>
<li>new是类型安全的（类型错误会报错），而malloc不是；</li>
<li>new一般由两步构成，分别是new操作和构造。new操作对应于malloc，但new操作可以重载，可以自定义内存分配策略，不做内存分配，甚至分配到非内存设备上，而malloc不行；</li>
<li>new将调用构造函数，而malloc不能；delete将调用析构函数，而free不能；</li>
<li>malloc&#x2F;free需要&lt;stdlib.h&gt;，new和delete不需要头文件支持。</li>
</ol>
<p>备注：free和delete之后，虽然释放了内存，但需要将指针指向NULL，否则会出现野指针的状况。</p>
<h3 id="extern和export"><a href="#extern和export" class="headerlink" title="extern和export"></a>extern和export</h3><p>为了访问其他代码文件中的变量或对象：</p>
<ul>
<li>extern：普通类型（基本数据类、结构和类）</li>
<li>export：模板类型</li>
</ul>
<h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><p>关键字explicit可以阻止不应该允许的经过构造函数进行隐式转换的发生，声明为explicit的构造函数不能在隐式转换中使用。</p>
<h3 id="异常处理try-catch-throw-finally"><a href="#异常处理try-catch-throw-finally" class="headerlink" title="异常处理try-catch-throw-finally"></a>异常处理try-catch-throw-finally</h3><p>使用try{}catch{}语句捕获异常，把可能发生异常的代码放在try{}语句中，如果本级没有catch到，异常会向上一级传递，函数调用处如果没有捕获住，则向更高一层的调用者，一直没有直到main函数跳出，并导致程序异常终止。</p>
<p>catch的作用是捕获异常，finally不管代码是否有异常都执行。try中如果有return，仍然需要执行finally语句。该情况下：</p>
<ol>
<li>执行return返回语句（return之后的语句内容），计算返回值，暂时存在一个临时变量中。</li>
<li>执行finally语句块。</li>
<li>return原来已经计算得到的结果值。</li>
<li>如果finally中又调用return语句，则try中的return会被忽略覆盖。</li>
</ol>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>要定义和实现一个类的成员函数为回调函数需要做3件事：</p>
<ol>
<li>声明</li>
<li>定义</li>
<li>设置触发条件：在函数中把回调函数名作为一个参数，以便系统调用。就是函数指针</li>
</ol>
<h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><ol>
<li>指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量本质上是同一个东西，只不过是原变量的一个别名而已。</li>
<li>可以有const指针，但是没有const引用；</li>
<li>指针可以有多级，但是引用只能是一级。</li>
<li>指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化。</li>
<li>指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。</li>
<li>“sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；</li>
<li>指针和引用的自增(++)运算意义不一样；</li>
</ol>
<h2 id="结构体与类"><a href="#结构体与类" class="headerlink" title="结构体与类"></a>结构体与类</h2><h3 id="C-类的大小计算"><a href="#C-类的大小计算" class="headerlink" title="C++类的大小计算"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengxinlinux/article/details/72836199">C++类的大小计算</a></h3><ul>
<li>首先，类大小的计算遵循结构体的对齐原则</li>
<li>类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响</li>
<li>虚函数对类的大小有影响，是因为虚函数表指针带来的影响</li>
<li>虚继承对类的大小有影响，是因为虚基表指针带来的影响</li>
<li>空类的大小是一个特殊情况,空类的大小为1</li>
<li>64位 int大小为4字节，指针大小为8字节。</li>
</ul>
<h3 id="已知String类定义，如何实现其函数体"><a href="#已知String类定义，如何实现其函数体" class="headerlink" title="已知String类定义，如何实现其函数体"></a>已知String类定义，如何实现其函数体</h3><p>已知String类定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    		<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str=<span class="literal">NULL</span>);	<span class="comment">// 通用构造函数</span></span><br><span class="line">    		<span class="built_in">String</span>(<span class="type">const</span> String &amp;str);		<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    		~<span class="built_in">String</span>();						<span class="comment">// 析构函数</span></span><br><span class="line">    		String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; rhs);	<span class="comment">// 赋值函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    		<span class="type">char</span>* m_data;					<span class="comment">// 用于保存字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数体实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    		<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str=<span class="literal">NULL</span>);	<span class="comment">// 通用构造函数</span></span><br><span class="line">    		<span class="built_in">String</span>(<span class="type">const</span> String&amp; str);		<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    		~<span class="built_in">String</span>();						<span class="comment">// 析构函数</span></span><br><span class="line">    		String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; rhs);	<span class="comment">// 赋值函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    		<span class="type">char</span>* m_data;					<span class="comment">// 用于保存字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        m_data[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String&amp; str)&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">String::~<span class="built_in">String</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值函数</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;rhs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">// 如果同一对象，直接返回</span></span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    <span class="comment">// 拷贝构造 </span></span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="内存分配的形式"><a href="#内存分配的形式" class="headerlink" title="内存分配的形式"></a>内存分配的形式</h3><ul>
<li>BBS段：存放程序中未初始化的全局数据和静态数据。BBS段术语静态内存分配，程序结束后静态变量资源由系统自动释放。</li>
<li>数据段：存放程序中已经初始化的全局变量。数据段属于静态内存分配。</li>
<li>代码段（文本段）：存放程序执行的代码和只读的常数变量，比如字符串常量。运行前已确认大小，通常只读。</li>
<li>堆：存放进程运行中被动态分配的内存段，大小不固定，可扩张或缩减。堆向上增长。(小于2GB)</li>
<li>栈：存放程序临时创建的局部变量，效率高，分配的内存容量有限。栈向下增长。（Win2MB,Linux8MB）</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="编译和连接的区别"><a href="#编译和连接的区别" class="headerlink" title="编译和连接的区别"></a>编译和连接的区别</h3><ul>
<li>编译：将预处理生成的文件，经过词法分析、语法分析、语义分析并经过优化后编译成若干个模块。即obj文件。</li>
<li>链接：由链接程序将编译后形成的一组目标模块以及它所需要的库函数链接在一起，形成一个完整的载入模型，主要解决模块间的相互引用问题。分为：地址和内存分配、符号解析、重定位三个步骤。</li>
</ul>
<h3 id="C-和C兼容"><a href="#C-和C兼容" class="headerlink" title="C++和C兼容"></a>C++和C兼容</h3><p>extern “C”。</p>
<p><strong>C++调用被C编译器编译后的函数，为什么要加extern “C”</strong>？ 为了支持重载，C++会转换函数名，但是C没有函数重载，函数名不变。如果不加区别，C++编译器找不到C的函数名，就无法调用。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p>除了抽象外</p>
<ul>
<li><p>封装：访问控制符</p>
</li>
<li><p>继承：使用现有类的所有功能，而不重新编写原来的类，目的是为了进行代码复用和支持多态。</p>
<ul>
<li>实现继承：使用基类的属性和方法而无需额外编码</li>
<li>可视继承：子窗体使用父窗体的外观和实现代码</li>
<li>接口继承：仅使用属性和方法，具体实现滞后到子类进行实现。</li>
</ul>
<p>前两种为类继承，后一种为（对象组合-&gt;接口继承以及纯虚函数）。</p>
</li>
<li><p>多态：一个实体同时具有多种形式，可以将父类对象设置成子对象的技术，父对象可以根据当前赋值给它的子对象的特性以不同的方式运作。</p>
</li>
</ul>
<h3 id="复制构造函数和赋值运算符的区别"><a href="#复制构造函数和赋值运算符的区别" class="headerlink" title="复制构造函数和赋值运算符的区别"></a>复制构造函数和赋值运算符的区别</h3><ol>
<li>复制构造函数生成新的类对象，赋值运算符不行（赋予的对象原来就有值）</li>
<li>由于复制构造函数是直接构造一个新的对象，初始化该对象时不用检验原对象是否和新对象相同。赋值运算符需要判断。</li>
<li>当类中有指针类型的成员变量时，一定要重写复制构造函数和赋值构造函数，不能使用默认的。</li>
</ol>
<h3 id="类成员的初始化顺序"><a href="#类成员的初始化顺序" class="headerlink" title="类成员的初始化顺序"></a>类成员的初始化顺序</h3><p>类成员变量的初始化顺序只与变量在类中的声明顺序有关，与在构造函数中的初始化列表的顺序无关。同时，静态成员变量先于实例变量，父类成员变量先于子类成员变量，父类构造函数先于子类构造函数。</p>
<p><strong>从全局看，变量的初始化顺序如下：</strong></p>
<ol>
<li>基类的静态变量或全局变量</li>
<li>派生类的静态变量或全局变量</li>
<li>基类的成员变量</li>
<li>派生类的成员变量</li>
</ol>
<h3 id="构造函数没有返回值，如何得知对象是否构造成功？"><a href="#构造函数没有返回值，如何得知对象是否构造成功？" class="headerlink" title="构造函数没有返回值，如何得知对象是否构造成功？"></a>构造函数没有返回值，如何得知对象是否构造成功？</h3><p>通知对象构造失败的唯一方法是在构造函数中抛出异常，抛出异常将导致对象的析构函数不被执行，当对象发生部分构造时，已经构造完毕的子对象将会逆序地被析构。</p>
<h3 id="C-中的空类默认产生哪些成员函数"><a href="#C-中的空类默认产生哪些成员函数" class="headerlink" title="C++中的空类默认产生哪些成员函数"></a>C++中的空类默认产生哪些成员函数</h3><p>C++中空类默认会产生以下6个函数：</p>
<ol>
<li>默认构造函数</li>
<li>复制构造函数</li>
<li>析构函数</li>
<li>赋值运算符重载函数</li>
<li>取址运算符重载函数</li>
<li>const取址运算符重载函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Empty</span>();</span><br><span class="line">    	<span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; );</span><br><span class="line">    	~<span class="built_in">Empty</span>();</span><br><span class="line">    	Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;);</span><br><span class="line">    	Empty* <span class="keyword">operator</span>&amp;();</span><br><span class="line">    	<span class="type">const</span> Empty* <span class="keyword">operator</span>&amp;() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="public、protected、private的区别是什么？"><a href="#public、protected、private的区别是什么？" class="headerlink" title="public、protected、private的区别是什么？"></a>public、protected、private的区别是什么？</h3><table>
<thead>
<tr>
<th align="center">基类性质</th>
<th align="center">继承性质</th>
<th align="center">派生类形式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">public</td>
<td align="center">public</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">public</td>
<td align="center">protected</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">public</td>
<td align="center">不能访问</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">protected</td>
<td align="center">protected</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">protected</td>
<td align="center">protected</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">protected</td>
<td align="center">不能访问</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">private</td>
<td align="center">private</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">private</td>
<td align="center">private</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">private</td>
<td align="center">不能访问</td>
</tr>
</tbody></table>
<h3 id="C-有哪些情况只能用初始化列表而不能用赋值"><a href="#C-有哪些情况只能用初始化列表而不能用赋值" class="headerlink" title="C++有哪些情况只能用初始化列表而不能用赋值"></a>C++有哪些情况只能用初始化列表而不能用赋值</h3><ol>
<li>当类中含有const（常量）、reference（引用）成员变量时，只能初始化，不能对它们进行赋值。常量不能被赋值，只能被初始化，所以必须在初始化列表中完成，C++的引用也一定要初始化，所以必须在初始化列表中完成。</li>
<li>基类的构造函数都需要初始化列表。构造函数的意思是先开辟空间然后为其赋值，只能算是赋值，不算初始化。</li>
<li>成员类型没有默认构造函数的类。</li>
</ol>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="什么是虚函数？"><a href="#什么是虚函数？" class="headerlink" title="什么是虚函数？"></a>什么是虚函数？</h3><p>指向基类的指针在操作它的多态类对象时，会根据不同的类对象调用其相应的函数，这个函数就是虚函数。</p>
<p>虚函数用virtual修饰函数名。</p>
<p>虚函数的作用是在程序运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数进行重新定义。</p>
<p>在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型，来实现统一的接口。如果派生类中没有对虚函数重新定义，则继承基类的虚函数。</p>
<h3 id="虚函数的实现机制"><a href="#虚函数的实现机制" class="headerlink" title="虚函数的实现机制"></a>虚函数的实现机制</h3><p>虚函数是通过一张虚函数表（virtual table）来实现的。该表是一个类的虚函数的地址表，解决了继承、覆盖的问题，保证它能真实反映实际的函数。</p>
<p>在有虚函数的类的实例中，虚函数表被分配在实例的内存中，所以当父类的指针操作一个子类的时候，这张虚函数表就显得非常重要，它指明了实际所应该调用的函数。</p>
<p>C++的编译器能够保证虚函数表的指针存在与对象实例中最前面的位置，通过对象实例的地址的得到这张虚函数表，然后就可以遍历其中的函数指针，并调用相应的函数。</p>
<p>举例来说，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚函数表的得到方式</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">Base b;</span><br><span class="line">Fun pfun = <span class="literal">NULL</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;虚函数表地址：&quot;</span> &lt;&lt; (<span class="type">int</span>*)(&amp;b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;虚函数表-第一个函数地址：&quot;</span> &lt;&lt; (<span class="type">int</span>*)*(<span class="type">int</span>*)(&amp;b) &lt;&lt; endl;</span><br><span class="line">pfun = (Fun)*((<span class="type">int</span>)*(<span class="type">int</span>*)(&amp;b));</span><br><span class="line"><span class="built_in">pfun</span>();	<span class="comment">// 运行第一个虚函数</span></span><br></pre></td></tr></table></figure>

<p><strong>具体怎么运行的呢？</strong></p>
<p>应在构造函数中进行虚函数表的创建和虚函数指针的初始化。根据构造函数的调用顺序，在构造子类对象时，要先调用父类的构造函数，此时编译器只“看到了”父类，并不知道后面是否还有继承者，它初始化父类对象的虚函数表的指针，该虚函数表指针指向父类的虚函数表。当执行子类的构造函数时，子类对象的虚函数表指针被初始化，指向自身的虚函数表。</p>
<p>当编译器发现一个类中有虚函数，便会立即为此类生成虚函数表，虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个指针vptr指向虚函数表。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行vptr与table的关联代码，将vptr指向对应的vtable，将类与此类的vtable联系起来，另外，在调用类的构造函数时，指向基础类的指针此时已经变为指向具体类的this指针，这样依靠此this指针即可得到正确的vtable。</p>
<p><strong>多继承</strong></p>
<p>多继承情况下，派生类中有多个虚函数表，虚函数的排列方式和继承的顺序一致。</p>
<p>派生类重写函数将会覆盖所有虚函数表的同名内容。</p>
<p>派生类自定义新的徐哈书将会在第一个类的虚函数表后进行扩充。</p>
<h3 id="C-如何实现多态"><a href="#C-如何实现多态" class="headerlink" title="C++如何实现多态"></a>C++如何实现多态</h3><p>C++通过虚函数实现多态。虚函数的本质就是通过基类访问派生类定义的函数。</p>
<p>每一个含有虚函数的类，其实例对象内部都有一个虚函数表指针。</p>
<p>该虚函数表指针被初始化为本类的虚函数表的内存地址，所以在程序中，不管对象类型如何转换，但该对象内部的虚函数表指针是固定的，这样才能实现动态地对对象函数进行调用，这就是C++多态的原理。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>由于在很多情况下，基类中不能对虚函数给出有意义的实现，只能把函数的实现留给该类的派生类去做。此时，就可以将函数定义为纯虚函数，编译器要求存在若干派生的非抽象类，则在派生类中必须予以重载以实现多态性。</p>
<p>对于纯虚函数，编译器要求在派生类中予以重载以实现多态性。含有纯虚函数的类成为抽象类，抽象类不能生成对象。</p>
<p>纯虚函数永远不会被调用，它们主要用来统一管理子类对象。</p>
<h3 id="C-多态种类"><a href="#C-多态种类" class="headerlink" title="C++多态种类"></a>C++多态种类</h3><ol>
<li>参数多态：采用参数化模板，通过给定不同的类型参数，使得一个结构有多种类型、模板。</li>
<li>引用多态：同样的操作可以用于一个类型及其子类型。</li>
<li>过载多态：指同一个名字在不同的上下文中有不同的类型。</li>
<li>强制多态：指把操作对象的类型强加以变换，以符合函数或操作符的要求。</li>
</ol>
<h3 id="什么函数不能声明为虚函数？"><a href="#什么函数不能声明为虚函数？" class="headerlink" title="什么函数不能声明为虚函数？"></a>什么函数不能声明为虚函数？</h3><p>一个类中将所有的成员函数都尽可能地设置为虚函数总是有益的，但是设置虚函数需要注意以下5个方面的内容：</p>
<ol>
<li>只有类的成员函数才能说明为虚函数。</li>
<li><strong>静态成员函数不能为虚函数</strong>，因为调用静态成员函数不要实例，但调用虚函数需要从一个实例中指向虚函数表的指针以得到函数的地址，因此调用虚函数需要一个实例，两者相互矛盾。</li>
<li>内联函数不能为虚函数。</li>
<li>构造函数不能为虚函数。因为构造函数是在对象完全构造之前运行的，换句话说，运行析构函数前，对象还没有生成，谈不上动态类型，会出现矛盾。</li>
<li>析构函数可以为虚函数，而且通常声明为虚函数。</li>
</ol>
<h3 id="是否可以把每个函数都声明为虚函数"><a href="#是否可以把每个函数都声明为虚函数" class="headerlink" title="是否可以把每个函数都声明为虚函数"></a>是否可以把每个函数都声明为虚函数</h3><p>代价就是：每个虚函数的对象在内存中都必须维护一个虚函数表，产生系统开销。</p>
<h3 id="C-中如何阻止一个类被实例化"><a href="#C-中如何阻止一个类被实例化" class="headerlink" title="C++中如何阻止一个类被实例化"></a>C++中如何阻止一个类被实例化</h3><p>C++中可以通过使用抽象类，或者将构造函数声明为private阻止一个类被实例化。</p>
<p><strong>一般在什么时候将构造函数声明为private</strong></p>
<p>要阻止编译器生成默认的复制构造函数的时候</p>
<p><strong>什么时候编译器会生成默认的复制构造函数</strong></p>
<p>只要自己没写，而程序需要，都会生成。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="OSI七层模型和TCP-x2F-IP四层模型，每层列举2个协议"><a href="#OSI七层模型和TCP-x2F-IP四层模型，每层列举2个协议" class="headerlink" title="OSI七层模型和TCP&#x2F;IP四层模型，每层列举2个协议"></a>OSI七层模型和TCP&#x2F;IP四层模型，每层列举2个协议</h3><p><strong>OSI七层模型及其包含的协议</strong></p>
<ol>
<li>物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为<strong>bit</strong>，主要包括的协议为：IEE802.3 CLOCK RJ45</li>
<li>数据链路层: 将比特组装成帧和点到点的传递,传输单位为<strong>帧</strong>,主要包括的协议为MAC VLAN PPP</li>
<li>网络层：负责数据包从源到宿的传递和网际互连，传输单位为<strong>包</strong>,主要包括的协议为IP ARP ICMP</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复，传输单位为<strong>报文</strong>,主要包括的协议为TCP UDP</li>
<li>会话层：建立、管理和终止会话，传输单位为<strong>SPDU</strong>，主要包括的协议为RPC NFS</li>
<li>表示层：对数据进行翻译、加密和压缩,传输单位为<strong>PPDU</strong>，主要包括的协议为JPEG ASII</li>
<li>应用层: 允许访问OSI环境的手段,传输单位为<strong>APDU</strong>，主要包括的协议为FTP HTTP DNS</li>
</ol>
<p><strong>TCP&#x2F;IP四层模型</strong></p>
<ol>
<li>网络接口层：MAC VLAN</li>
<li>网络层:IP ARP ICMP</li>
<li>传输层:TCP UDP</li>
<li>应用层:HTTP DNS SMTP</li>
</ol>
<h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><h3 id="UDP协议报头和TCP协议报头"><a href="#UDP协议报头和TCP协议报头" class="headerlink" title="UDP协议报头和TCP协议报头"></a>UDP协议报头和TCP协议报头</h3><p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509811/blog/h9u1i0fckxh938ud1goj.webp" alt="UDP"></p>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509811/blog/hhh2hj1fp9xtz70djk5r.png" alt="TCP"></p>
<h3 id="TCP保证可靠性"><a href="#TCP保证可靠性" class="headerlink" title="TCP保证可靠性"></a>TCP保证可靠性</h3><ol>
<li><p>校验和</p>
</li>
<li><p>序列号</p>
</li>
<li><p>确认应答</p>
</li>
<li><p>重发控制</p>
</li>
<li><p>连接管理</p>
<ol>
<li>三次握手</li>
<li>四次挥手</li>
</ol>
</li>
<li><p>TCP以段为单位发送数据</p>
</li>
<li><p>窗口控制</p>
<ol>
<li>利用窗口控制提高速度：窗口大小指无需等待确认应答而可以继续发送数据的最大值。</li>
<li>窗口控制与重发控制</li>
</ol>
</li>
<li><p>流控制：限流</p>
</li>
<li><p>拥塞控制如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。</p>
<p>慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p>
<p>拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答&#x2F;每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p>
<p>将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p>
<p>快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</p>
<p>然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p>
<p>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</p>
</li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP-responce-code"><a href="#HTTP-responce-code" class="headerlink" title="HTTP responce code"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/http/http-status-codes.html">HTTP responce code</a></h3><p>分类：</p>
<ul>
<li>1** 信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2** 成功，操作被成功接收并处理</li>
<li>3** 重定向，需要进一步的操作以完成请求</li>
<li>4** 客户端错误，请求包含语法错误或无法完成请求</li>
<li>5** 服务器错误，服务器在处理请求的过程中发生了错误</li>
</ul>
<p>常用状态码</p>
<ul>
<li>200 请求成功</li>
<li>301 资源（网页等）被永久转移到其他URL</li>
<li>404 请求的资源不存在</li>
<li>500 内部服务器错误</li>
</ul>
<h3 id="GET-x2F-POST区别"><a href="#GET-x2F-POST区别" class="headerlink" title="GET&#x2F;POST区别"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/logsharing/p/8448446.html">GET&#x2F;POST区别</a></h3><ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<h3 id="HTTP和HTTPS的区别，以及HTTPS的缺点"><a href="#HTTP和HTTPS的区别，以及HTTPS的缺点" class="headerlink" title="HTTP和HTTPS的区别，以及HTTPS的缺点"></a>HTTP和HTTPS的区别，以及HTTPS的缺点</h3><p><strong>HTTP协议和HTTPS协议区别</strong>如下：</p>
<ol>
<li>HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</li>
<li>HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</li>
<li>HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</li>
<li>HTTP协议端口是80，HTTPS协议端口是443</li>
</ol>
<p><strong>HTTPS优点：</strong></p>
<ul>
<li>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</li>
<li>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</li>
</ul>
<p>HTTPS缺点：</p>
<ul>
<li>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</li>
<li>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</li>
</ul>
<h2 id="Socket和Socket编程"><a href="#Socket和Socket编程" class="headerlink" title="Socket和Socket编程"></a>Socket和Socket编程</h2><p>学习材料和推荐博文：<a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/">C&#x2F;C++ socket编程教程：1天玩转socket通信技术</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md</a></p>
<h3 id="I-x2F-O模型（转）"><a href="#I-x2F-O模型（转）" class="headerlink" title="I&#x2F;O模型（转）"></a>I&#x2F;O模型（转）</h3><p>一个输入操作通常包括两个阶段：</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。Unix的5种IO模型是：</p>
<ul>
<li><p><strong>阻塞式 I&#x2F;O</strong><br>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>
</li>
<li><p><strong>非阻塞式 I&#x2F;O</strong><br>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I&#x2F;O 是否完成，这种方式称为轮询（polling）。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>
</li>
<li><p><strong>I&#x2F;O 复用</strong><br>（select 和 poll）使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p>它可以让单个进程具有处理多个 I&#x2F;O 事件的能力。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O。</p>
<p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
</li>
<li><p><strong>信号驱动式 I&#x2F;O（SIGIO）</strong><br>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高。</p>
</li>
<li><p><strong>异步 I&#x2F;O（AIO）</strong><br>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I&#x2F;O 与信号驱动 I&#x2F;O 的区别在于，异步 I&#x2F;O 的信号是通知应用进程 I&#x2F;O 完成，而信号驱动 I&#x2F;O 的信号是通知应用进程可以开始 I&#x2F;O。</p>
</li>
</ul>
<p>这五种I&#x2F;O模型的区别是：</p>
<ul>
<li>同步 I&#x2F;O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>
<li>异步 I&#x2F;O：第二阶段应用进程不会阻塞。</li>
</ul>
<p>同步 I&#x2F;O 包括阻塞式 I&#x2F;O、非阻塞式 I&#x2F;O、I&#x2F;O 复用和信号驱动 I&#x2F;O ，它们的主要区别在第一个阶段。</p>
<p>非阻塞式 I&#x2F;O 、信号驱动 I&#x2F;O 和异步 I&#x2F;O 在第一阶段不会阻塞。</p>
<h3 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h3><ul>
<li>SOCK_STREAM 表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常见的 http 协议就使用 SOCK_STREAM 传输数据，因为要确保数据的正确性，否则网页不能正常解析。</li>
<li>SOCK_DGRAM 表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为SOCK_DGRAM 所做的校验工作少，所以效率比 SOCK_STREAM 高。视频聊天和语音聊天就是用SOCK_DGRAM。备注：SOCK_DGRAM 没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。</li>
</ul>
<p>IP地址和端口能够在广袤的互联网中定位到要通信的程序，协议和数据传输方式规定了如何传输数据，有了这些，两台计算机就可以通信了。</p>
<h3 id="Socket程序演示"><a href="#Socket程序演示" class="headerlink" title="Socket程序演示"></a>Socket程序演示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Windows下，需要加载Windows Socket的DLL，并且使用WSAStartup()函数进行初始化来指明版本</span></span><br><span class="line">    <span class="comment">// int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="comment">// AF_INET表示使用IPV4地址，</span></span><br><span class="line">    <span class="comment">// SOCK_STREAM表示使用面向连接的数据传输方式，IPPROTO_TCP表示使用TCP协议</span></span><br><span class="line">    <span class="comment">// Linux下SOCKET是一种文件，有文件描述符，socket返回int类型</span></span><br><span class="line">    <span class="type">int</span> serv_sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="comment">// Windows下使用文件句柄概念，返回SOCKET类型，</span></span><br><span class="line">    <span class="comment">// SOCKET servSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span></span><br><span class="line">    <span class="comment">// 两者都是用write()/read()或者recv()/send()对进行IO操作</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将套接字和IP、端口绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="comment">// 将套接字serv_sock与特定的IP地址和端口进行绑定</span></span><br><span class="line">    <span class="comment">// socket函数确定了套接字的各种属性，</span></span><br><span class="line">    <span class="comment">// bind函数让套接字与特定的IP和端口对应起来，、客户端才能连接到该套接字</span></span><br><span class="line">    <span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态，等待用户发起请求</span></span><br><span class="line">    <span class="comment">// listen是进入被动监听状态，指套接字一直处于“睡眠中”，指导客户端发起请求才能连接到该套接字</span></span><br><span class="line">    <span class="built_in">listen</span>(serv_sock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clnt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_addr_size = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="comment">// accept函数用来接受客户端请求，一旦执行到这里就会被阻塞（暂停运行），直到客户端发起请求</span></span><br><span class="line">    <span class="type">int</span> clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向套接字中写入数据就是向客户端发送数据</span></span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clnt_sock, str, <span class="built_in">sizeof</span>(str));</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="comment">// 跟普通文件操作一样，socket在使用完毕后也要close关闭</span></span><br><span class="line">    <span class="comment">// Windows中使用closesocket()</span></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器（特定的IP和端口）发起请求</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="comment">// 客户端通过connect向服务端发起请求，服务端的IP和端口保存在sockaddr_in结构体中</span></span><br><span class="line">    <span class="comment">// 直到服务器传回数据后，connect才运行结束</span></span><br><span class="line">    <span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//读取服务器传回的数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">40</span>];</span><br><span class="line">    <span class="comment">// 从套接字文件读物数据</span></span><br><span class="line">    <span class="built_in">read</span>(sock, buffer, <span class="built_in">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, buffer);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数、函数说明"><a href="#参数、函数说明" class="headerlink" title="参数、函数说明"></a>参数、函数说明</h3><h4 id="socket-函数创建套接字"><a href="#socket-函数创建套接字" class="headerlink" title="socket()函数创建套接字"></a>socket()函数创建套接字</h4><p>socket() 函数用来创建套接字，确定套接字的各种属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。也可以使用PF前缀，PF是“Protocol Family”的简写，它和AF是一样的。例如，PF_INET 等价于 AF_INET，PF_INET6 等价于 AF_INET6。</li>
<li>type 为数据传输方式，常用的有 SOCK_STREAM 和 SOCK_DGRAM.</li>
<li>protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。</li>
</ul>
<h4 id="bind-和connect-函数"><a href="#bind-和connect-函数" class="headerlink" title="bind()和connect()函数"></a>bind()和connect()函数</h4><p>服务器端要用 bind() 函数将套接字与特定的IP地址和端口绑定起来，只有这样，流经该IP地址和端口的数据才能交给套接字处理；而客户端要用 connect() 函数建立连接。</p>
<p>bind原型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sock, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(SOCKET sock, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line"><span class="type">int</span> serv_sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建sockaddr_in结构体变量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将套接字和IP、端口绑定</span></span><br><span class="line"><span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br></pre></td></tr></table></figure>

<p>我们使用 sockaddr_in 结构体定义信息，然后再强制转换为 sockaddr 类型，送给函数。是因为sockaddr_in 和 sockaddr大小一致，但是不方便直接给sockaddr赋值。</p>
<p>connect原型,含义与bind相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sock, <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">socklen_t</span> addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(SOCKET sock, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure>

<h4 id="listen-和accept-函数"><a href="#listen-和accept-函数" class="headerlink" title="listen()和accept()函数"></a>listen()和accept()函数</h4><p>对于服务器端程序，使用 bind() 绑定套接字后，还需要使用 listen() 函数让套接字进入被动监听状态，再调用 accept() 函数，就可以随时响应客户端的请求了。</p>
<p><strong>listen函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> backlog)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(SOCKET sock, <span class="type">int</span> backlog)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure>

<p>sock 为需要进入监听状态的套接字，backlog 为请求队列的最大长度。所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。</p>
<p><strong>请求队列</strong>  当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。</p>
<p>缓冲区的长度（能存放多少个客户端请求）可以通过 listen() 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是10或者20。</p>
<p>如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。</p>
<p>当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误，对于 Windows，客户端会收到 WSAECONNREFUSED 错误。</p>
<p>注意：listen() 只是让套接字处于监听状态，并没有接收请求。接收请求需要使用 accept() 函数。</p>
<p><strong>accept() 函数</strong></p>
<p>当套接字处于监听状态时，可以通过 accept() 函数来接收客户端请求</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sock, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(SOCKET sock, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure>

<p>它的参数与 listen() 和 connect() 是相同的：sock 为服务器端套接字，addr 为 sockaddr_in 结构体变量，addrlen 为参数 addr 的长度，可由 sizeof() 求得。</p>
<p>accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，大家注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。</p>
<p>最后需要说明的是：listen() 只是让套接字进入监听状态，并没有真正接收客户端请求，listen() 后面的代码会继续执行，直到遇到 accept()。accept() 会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。</p>
<h4 id="数据发送与接收"><a href="#数据发送与接收" class="headerlink" title="数据发送与接收"></a>数据发送与接收</h4><p>Linux 不区分套接字文件和普通文件，使用 write() 可以向套接字中写入数据，使用 read() 可以从套接字中读取数据。两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 write() 向套接字写入数据，客户端就能收到，然后再使用 read() 从套接字中读取出来，就完成了一次通信。</p>
<p><strong>write()</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd 为要写入的文件的描述符，buf 为要写入的数据的缓冲区地址，nbytes 为要写入的数据的字节数。</p>
<p>write() 函数会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 -1。</p>
<p><strong>read()</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd 为要读取的文件的描述符，buf 为要接收数据的缓冲区地址，nbytes 为要读取的数据的字节数。</p>
<p>read() 函数会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。</p>
<h4 id="迭代服务器和客户端"><a href="#迭代服务器和客户端" class="headerlink" title="迭代服务器和客户端"></a>迭代服务器和客户端</h4><p>像Web服务器那样一直接受客户端的请求呢？能，使用 while 循环即可。</p>
<p>需要注意的是：server.cpp 中调用 closesocket() 不仅会关闭服务器端的 socket，还会通知客户端连接已断开，客户端也会清理 socket 相关资源，所以 client.cpp 中需要将 socket() 放在 while 循环内部，因为每次请求完毕都会清理 socket，下次发起请求时需要重新创建。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器</span></span><br><span class="line">	<span class="built_in">bind</span>(servSock, (SOCKADDR*)&amp;sockAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line">    <span class="comment">//进入监听状态</span></span><br><span class="line">    <span class="built_in">listen</span>(servSock, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    <span class="type">int</span> nSize = <span class="built_in">sizeof</span>(SOCKADDR);</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//缓冲区</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        SOCKET clntSock = <span class="built_in">accept</span>(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);</span><br><span class="line">        <span class="type">int</span> strLen = <span class="built_in">recv</span>(clntSock, buffer, BUF_SIZE, <span class="number">0</span>);  <span class="comment">//接收客户端发来的数据</span></span><br><span class="line">        <span class="built_in">send</span>(clntSock, buffer, strLen, <span class="number">0</span>);  <span class="comment">//将数据原样返回</span></span><br><span class="line">        <span class="built_in">closesocket</span>(clntSock);  <span class="comment">//关闭套接字</span></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUF_SIZE);  <span class="comment">//重置缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">closesocket</span>(servSock);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">    <span class="type">char</span> bufSend[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> bufRecv[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//创建套接字</span></span><br><span class="line">        SOCKET sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">        <span class="built_in">connect</span>(sock, (SOCKADDR*)&amp;sockAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line">        <span class="comment">//获取用户输入的字符串并发送给服务器</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input a string: &quot;</span>);</span><br><span class="line">        <span class="built_in">gets</span>(bufSend);</span><br><span class="line">        <span class="built_in">send</span>(sock, bufSend, <span class="built_in">strlen</span>(bufSend), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//接收服务器传回的数据</span></span><br><span class="line">        <span class="built_in">recv</span>(sock, bufRecv, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//输出接收到的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, bufRecv);</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">memset</span>(bufSend, <span class="number">0</span>, BUF_SIZE);  <span class="comment">//重置缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>(bufRecv, <span class="number">0</span>, BUF_SIZE);  <span class="comment">//重置缓冲区</span></span><br><span class="line">        <span class="built_in">closesocket</span>(sock);  <span class="comment">//关闭套接字</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="scoket缓冲区"><a href="#scoket缓冲区" class="headerlink" title="scoket缓冲区"></a>scoket缓冲区</h3><p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509812/blog/vnjjtb5qpypkrpzewbic.jpg" alt="TCP套接字缓冲区"></p>
<p>I&#x2F;O缓冲区特性可整理如下：</p>
<ul>
<li>I&#x2F;O缓冲区在每个TCP套接字中单独存在；</li>
<li>I&#x2F;O缓冲区在创建套接字时自动生成；</li>
<li>即使关闭套接字也会继续传送输出缓冲区中遗留的数据；</li>
<li>关闭套接字将丢失输入缓冲区中的数据。</li>
</ul>
<h3 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h3><p>对于TCP套接字（默认情况下），当使用 write()&#x2F;send() 发送数据时：</p>
<ol>
<li>首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()&#x2F;send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()&#x2F;send() 函数继续写入数据。</li>
<li>如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()&#x2F;send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()&#x2F;send() 才会被唤醒。</li>
<li>如果要写入的数据大于缓冲区的最大长度，那么将分批写入。</li>
<li>直到所有数据被写入缓冲区 write()&#x2F;send() 才能返回。</li>
</ol>
<p>这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。</p>
<h3 id="TCP的粘包问题和数据的无边界性"><a href="#TCP的粘包问题和数据的无边界性" class="headerlink" title="TCP的粘包问题和数据的无边界性"></a>TCP的粘包问题和数据的无边界性</h3><p>这就是数据的“粘包”问题，客户端发送的多个数据包被当做一个数据包接收。也称数据的无边界性，read()&#x2F;recv() 函数不知道数据包的开始或结束标志（实际上也没有任何开始或结束标志），只把它们当做连续的数据流来处理。</p>
<p>假设我们希望客户端每次发送一位学生的学号，让服务器端返回该学生的姓名、住址、成绩等信息，这时候可能就会出现问题，服务器端不能区分学生的学号。例如第一次发送 1，第二次发送 3，服务器可能当成 13 来处理，返回的信息显然是错误的。</p>
<h3 id="TCP数据报结构和三次握手"><a href="#TCP数据报结构和三次握手" class="headerlink" title="TCP数据报结构和三次握手"></a>TCP数据报结构和三次握手</h3><p><strong>数据报</strong></p>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509813/blog/i7b20ngluerocikmstcn.jpg" alt="数据报"></p>
<ul>
<li>序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。</li>
<li>确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack &#x3D; Seq + 1。</li>
<li>标志位<ul>
<li>URG：紧急指针（urgent pointer）有效。</li>
<li>ACK：确认序号有效。</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>RST：重置连接。</li>
<li>SYN：建立一个新连接。</li>
<li>FIN：断开一个连接。</li>
</ul>
</li>
</ul>
<blockquote>
<p>对英文字母缩写的总结：Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。</p>
</blockquote>
<p><strong>TCP三次握手和Socket中的建立流程</strong></p>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509813/blog/vqxppvo38dkqqvgchxq3.jpg" alt="三次握手"></p>
<ol start="0">
<li><p>客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于 <code>CLOSED</code>状态；服务器端调用 listen() 函数后，套接字进入 <code>LISTEN</code>状态，开始监听客户端请求。</p>
</li>
<li><p>当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。</p>
<p>同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了 <code>SYN-SEND</code>状态。</p>
</li>
<li><p>服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。</p>
<p>服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。</p>
<p>服务器将数据包发出，进入 <code>SYN-RECV</code>状态。</p>
</li>
<li><p>客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。</p>
<p>接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。</p>
<p>客户端将数据包发出，进入 <code>ESTABLISED</code>状态，表示连接已经成功建立。</p>
</li>
<li><p>服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。<br>服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入 <code>ESTABLISED</code>状态。</p>
</li>
</ol>
<p>至此，客户端和服务器都进入了 <code>ESTABLISED</code>状态，连接建立成功，接下来就可以收发数据了。</p>
<h3 id="TCP数据的传输过程"><a href="#TCP数据的传输过程" class="headerlink" title="TCP数据的传输过程"></a>TCP数据的传输过程</h3><p><strong>正常情况</strong></p>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509814/blog/jggacsldcdfjqd1s9iki.jpg" alt="传输过程"></p>
<p>上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。</p>
<blockquote>
<p>为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。</p>
</blockquote>
<p>此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号：</p>
<blockquote>
<p>Ack号 &#x3D; Seq号 + 传递的字节数 + 1</p>
</blockquote>
<p>与三次握手协议相同，最后加1是为了告诉对方要传递的Seq号。</p>
<p><strong>数据包丢失情况</strong></p>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509814/blog/drt4adqx0ddzqzmcmijn.jpg" alt="TCP套接字数据传输过程中发生错误"></p>
<p>上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。<br>为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。</p>
<blockquote>
<p>上图演示的是数据包丢失的情况，也会有 ACK 包丢失的情况，一样会重传。</p>
</blockquote>
<p><strong>重传超时时间（RTO, Retransmission Time Out)</strong></p>
<p>这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。</p>
<blockquote>
<p>往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。</p>
</blockquote>
<p><strong>重传次数</strong></p>
<p>TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。</p>
<p><strong>最后需要说明的是，发送端只有在收到对方的 ACK 确认包后，才会清空输出缓冲区中的数据。</strong></p>
<h3 id="TCP四次握手断开连接"><a href="#TCP四次握手断开连接" class="headerlink" title="TCP四次握手断开连接"></a>TCP四次握手断开连接</h3><p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509815/blog/aqx8kewuxidhcokmcwkw.jpg" alt="断开连接"></p>
<ol start="0">
<li>建立连接后，客户端和服务器都处于 <code>ESTABLISED</code>状态。</li>
<li>客户端发起断开连接的请求，客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入 <code>FIN_WAIT_1</code>状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。</li>
<li>服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入 <code>CLOSE_WAIT</code>状态。<br>注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。</li>
<li>客户端收到“确认包”后进入 <code>FIN_WAIT_2</code>状态，等待服务器准备完毕后再次发送数据包。</li>
<li>等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入 <code>LAST_ACK</code>状态。</li>
<li>客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入 <code>TIME_WAIT</code>状态。</li>
<li>服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入 <code>CLOSED</code>状态。</li>
</ol>
<p><strong>关于 TIME_WAIT 状态的说明</strong></p>
<p>客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？</p>
<p>TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器A每次向机器B发送数据包后，都要求机器B”确认“，回传ACK包，告诉机器A我收到了，这样机器A才能知道数据传送成功了。如果机器B没有回传ACK包，机器A会重新发送，直到机器B回传ACK包。</p>
<p>客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。那么，要等待多久呢？</p>
<p>数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为报文最大生存时间（MSL，Maximum Segment Lifetime）。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包。</p>
<h3 id="socket优雅地断开连接–shutdown"><a href="#socket优雅地断开连接–shutdown" class="headerlink" title="socket优雅地断开连接–shutdown()"></a>socket优雅地断开连接–shutdown()</h3><p>调用 close()&#x2F;closesocket() 函数意味着完全断开连接，即不能发送数据也不能接收数据，这种“生硬”的方式有时候会显得不太“优雅”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> howto)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(SOCKET s, <span class="type">int</span> howto)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure>

<p>至于什么时候需要调用 shutdown() 函数，下节我们会以文件传输为例进行讲解。</p>
<p><strong>close()&#x2F;closesocket()和shutdown()的区别</strong></p>
<ol>
<li>确切地说，close() &#x2F; closesocket() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，之后再也不能使用该套接字，与C语言中的 fclose() 类似。应用程序关闭套接字后，与该套接字相关的连接和缓存也失去了意义，TCP协议会自动触发关闭连接的操作。</li>
<li>shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() &#x2F; closesocket() 将套接字从内存清除。</li>
</ol>
<p>默认情况下，close()&#x2F;closesocket() 会立即向网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。也就意味着，调用 close()&#x2F;closesocket() 将丢失输出缓冲区中的数据，而调用 shutdown() 不会。</p>
<h3 id="socket网络字节序-htons-函数以及大端序小端序"><a href="#socket网络字节序-htons-函数以及大端序小端序" class="headerlink" title="socket网络字节序+htons()函数以及大端序小端序"></a>socket网络字节序+htons()函数以及大端序小端序</h3><p>CPU向内存保存数据的方式有两种，假设在 0x20 号开始的地址中保存4字节 int 型数据 0x12345678</p>
<ul>
<li>大端序（Big Endian）：高位字节存放到低位地址（高位字节在前）。<br><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509816/blog/satn1uahf2iiyxpzdoxl.jpg" alt="大端序"></li>
<li>小端序（Little Endian）：高位字节存放到高位地址（低位字节在前）。<br><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509816/blog/msoulmxqwybky9zquxwi.jpg" alt="小端序"></li>
</ul>
<p>不同CPU保存和解析数据的方式不同（主流的Intel系列CPU为小端序），小端序系统和大端序系统通信时会发生数据解析错误。因此在发送数据前，要将数据转换为统一的格式——网络字节序（Network Byte Order）。网络字节序统一为大端序。</p>
<p>主机A先把数据转换成大端序再进行网络传输，主机B收到数据后先转换为自己的格式再解析。</p>
<p>htons() 函数用来将当前主机字节序转换为网络字节序，其中 <code>h</code>代表主机（host）字节序，<code>n</code>代表网络（network）字节序，<code>s</code>代表short，htons 是 h、to、n、s 的组合，可以理解为”将short型数据从当前主机字节序转换为网络字节序“。</p>
<p>常见的网络字节转换函数有：</p>
<ul>
<li>htons()：host to network short，将short类型数据从主机字节序转换为网络字节序。</li>
<li>ntohs()：network to host short，将short类型数据从网络字节序转换为主机字节序。</li>
<li>htonl()：host to network long，将long类型数据从主机字节序转换为网络字节序。</li>
<li>ntohl()：network to host long，将long类型数据从网络字节序转换为主机字节序。</li>
</ul>
<p>注意：为sockaddr_in成员赋值时需要显式地将主机字节序转换为网络字节序，而通过 write()&#x2F;send() 发送数据时TCP协议会自动转换为网络字节序，不需要再调用相应的函数。</p>
<h3 id="在socket中使用域名"><a href="#在socket中使用域名" class="headerlink" title="在socket中使用域名"></a>在socket中使用域名</h3><p>客户端中直接使用IP地址会有很大的弊端，一旦IP地址变化（IP地址会经常变动），客户端软件就会出现错误。</p>
<p>而使用域名会方便很多，注册后的域名只要每年续费就永远属于自己的，更换IP地址时修改域名解析即可，不会影响软件的正常使用。</p>
<p><strong>通过域名获取IP地址</strong></p>
<p>域名仅仅是IP地址的一个助记符，目的是方便记忆，通过域名并不能找到目标计算机，通信之前必须要将域名转换成IP地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span> *<span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span> *hostname);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>&#123;</span><br><span class="line">    <span class="type">char</span> *h_name;<span class="comment">// 官方域名（Official domain name）。官方域名代表某一主页</span></span><br><span class="line">    <span class="type">char</span> **h_aliases;  <span class="comment">//别名，可以通过多个域名访问同一主机。同一IP地址可以绑定多个域名</span></span><br><span class="line">    <span class="type">int</span>  h_addrtype;  <span class="comment">// 不仅支持 IPv4，还支持 IPv6，可以通过此成员获取IP地址的地址族</span></span><br><span class="line">    <span class="type">int</span>  h_length;  <span class="comment">//保存IP地址长度。IPv4 的长度为4个字节，IPv6 的长度为16个字节。</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list;  <span class="comment">//通过该成员以整数形式保存域名对应的IP地址。对于用户较多的服务器，可能会分配多个IP地址给同一域名，利用多个服务器进行均衡负载。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="理解UDP套接字"><a href="#理解UDP套接字" class="headerlink" title="理解UDP套接字"></a>理解UDP套接字</h3><p>UDP 是非连接的传输协议，没有建立连接和断开连接的过程，它只是简单地把数据丢到网络中，也不需要ACK包确认。</p>
<p>UDP 传输数据就好像我们邮寄包裹，邮寄前需要填好寄件人和收件人地址，之后送到快递公司即可，但包裹是否正确送达、是否损坏我们无法得知，也无法保证。UDP 协议也是如此，它只管把数据包发送到网络，然后就不管了，如果数据丢失或损坏，发送端是无法知道的，当然也不会重发。</p>
<p>如果只考虑可靠性，TCP的确比UDP好。但UDP在结构上比TCP更加简洁，不会发送ACK的应答消息，也不会给数据包分配Seq序号，所以UDP的传输效率有时会比TCP高出很多，编程中实现UDP也比TCP简单。</p>
<p>UDP 的可靠性虽然比不上TCP，但也不会像想象中那么频繁地发生数据损毁，在更加重视传输效率而非可靠性的情况下，UDP是一种很好的选择。比如视频通信或音频通信，就非常适合采用UDP协议；通信时数据必须高效传输才不会产生“卡顿”现象，用户体验才更加流畅，如果丢失几个数据包，视频画面可能会出现“雪花”，音频可能会夹带一些杂音，这些都是无妨的。</p>
<p>与UDP相比，TCP的生命在于流控制，这保证了数据传输的正确性。</p>
<p>最后需要说明的是：TCP的速度无法超越UDP，但在收发某些类型的数据时有可能接近UDP。例如，每次交换的数据量越大，TCP 的传输速率就越接近于 UDP。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>推荐博文：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xkfz007/archive/2012/10/08/2715163.html">《CPU与内存的那些事》</a></p>
<p>十一篇文章讲解了计算机系统的重要内容，补知识靠他了。</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>1. CPU的等待有多久?</strong></li>
<li><input disabled="" type="checkbox"> <strong>2. CPU如何操作内存</strong></li>
<li><input disabled="" type="checkbox"> <strong>3. 主板芯片组与内存映射</strong></li>
<li><input disabled="" type="checkbox"> <strong>4. 计算机的引导过程</strong></li>
<li><input disabled="" type="checkbox"> <strong>5. 内核引导过程</strong></li>
<li><input disabled="" type="checkbox"> <strong>6. 内存地址转换与分段</strong></li>
<li><input disabled="" type="checkbox"> <strong>7. CPU的运行环, 特权级与保护</strong></li>
<li><input disabled="" type="checkbox"> <strong>8. Cache: 一个隐藏并保存数据的场所</strong></li>
<li><input disabled="" type="checkbox"> <strong>9. 剖析程序的内存布局</strong></li>
<li><input disabled="" type="checkbox"> <strong>10. 内核是如何管理内存的</strong></li>
<li><input disabled="" type="checkbox"> <strong>11. 页面缓存-内存与文件的那些事</strong></li>
</ul>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，它是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分配的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可以为同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p>引入线程的优点：</p>
<ol>
<li>易于调度；</li>
<li>提高并发性。通过线程可以方便有效地实现并发；</li>
<li>开销小。创建线程比创建进程要快，所需要的开销也更少；</li>
<li>有利于发挥多处理器的功能。通过创建多线程，每个线程都在一个处理器上运行，从而实现应用程序的并行，使每个处理器都得到充分运行。</li>
</ol>
<p><strong>区别</strong></p>
<ol>
<li>一个线程必定属于也只能属于一个进程，而一个进程可以拥有多个线程并且至少拥有一个进程；</li>
<li>属于一个进程的所有线程共享该进程的所有资源，包括打开的文件、创建的Socket等。不同的进程互相独立。</li>
<li>线程又被成为轻量级进程，进程有进程控制块，线程也有线程控制块。</li>
<li>进程是程序的一次执行，线程可以理解为程序中一段程序片段的执行。</li>
<li>每个进程都有独立的内存空间，而线程共享所属进程的内存空间。</li>
</ol>
<h3 id="线程同步的机制"><a href="#线程同步的机制" class="headerlink" title="线程同步的机制"></a>线程同步的机制</h3><ol>
<li>互斥量（mutex）：为协调对一个共享资源的单独访问而设计，只有拥有互斥量的线程才有权限去访问系统的公共资源，因为互斥量只有一个。</li>
<li>临界区（critical section）：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</li>
<li>事件（event）：用来通知线程有一些事件已经发生，从而启动后继任务的开始。</li>
<li>信号量（semaphore）：为控制一个具有有限数量的用户资源而设计，允许多个线程在同一个时刻去访问同一个资源，但一般需要限制同一时刻访问此类资源的最大线程数目。</li>
</ol>
<h3 id="Linux进程间通信方式（IPC-Inter-Process-Communication）"><a href="#Linux进程间通信方式（IPC-Inter-Process-Communication）" class="headerlink" title="Linux进程间通信方式（IPC: Inter-Process Communication）"></a>Linux进程间通信方式（IPC: Inter-Process Communication）</h3><p><strong>进程通信的目的是什么？</strong></p>
<ol>
<li>数据传输</li>
<li>共享数据</li>
<li>通知事件</li>
<li>进程控制</li>
</ol>
<p><strong>通信方式有哪些？</strong></p>
<ol>
<li>管道（pipe）流管道（s_pipe）,有名管道（FIFO）：数据传输<br>管道半双工，流管道双工，有名管道克服管道没有名字。</li>
<li>信号量：共享资源<br>本质就是一个计数器。</li>
<li>消息队列：数据传输<br>消息队列是消息的链表，克服了信号传递信息少的问题。</li>
<li>信号：通知事件&#x2F;进程控制<br>主要作为进程间以及同一进程不同线程间的同步手段</li>
<li>共享内存：共享数据</li>
<li>套接字：数据传输<br>可以跨进程，也可以跨机器。</li>
</ol>
<h3 id="并发（concurrency）和并行（parallelism）"><a href="#并发（concurrency）和并行（parallelism）" class="headerlink" title="并发（concurrency）和并行（parallelism）"></a>并发（concurrency）和并行（parallelism）</h3><ul>
<li>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核CPU上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</li>
<li>并行（parallelism）：指严格物理意义上的同时运行，比如多核CPU，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的CPU都是往多核方面发展。</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务和短作业优先"><a href="#先来先服务和短作业优先" class="headerlink" title="先来先服务和短作业优先"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/Houchaoqun_XMU/article/details/55539362">先来先服务和短作业优先</a></h3><p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509817/blog/fbl93v07e0tdxewafqbm.png" alt="调度算法"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理的方式"><a href="#内存管理的方式" class="headerlink" title="内存管理的方式"></a>内存管理的方式</h3><p>主流：段页式管理。</p>
<ol>
<li>块式管理：把主存分为一大块一大块的，当所需的程序片段不在主存时就分配一块主存空间，把程序片段载入主存。比较浪费</li>
<li>页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。</li>
<li>段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比也是管理高很多，但是缺点就是一个程序片段可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。</li>
<li>段页式管理：结合了段式管理和页式管理的优点。把主存先分成若干段，每个段又分成若干页。段页式管理每取一数据，要访问3次内存。</li>
</ol>
<h3 id="分页和分段存储管理有何区别？"><a href="#分页和分段存储管理有何区别？" class="headerlink" title="分页和分段存储管理有何区别？"></a>分页和分段存储管理有何区别？</h3><p>(1) 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。</p>
<p>(2) 页的大小固定且由系统决定；而段的长度却不固定，决定于用户所编写的程序。</p>
<p>(3) 分页的地址空间是一维的，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存简称虚存，是计算机系统内存管理的一种技术。相对与物理内存而言，是假内存。使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），允许程序员编写运行比实际系统拥有的内存大得多的程序，这使得许多大型软件项目能够在有限内存资源的系统上实现。</p>
<p>实际上是被分割成多个物理内存碎片，还有部分暂时存储在外部存储磁盘上，在需要时进行数据交换，虚拟内存的好处：</p>
<ol>
<li>扩大地址空间，无论段式虚存，还是页式虚存，或段式虚存，寻址空间都比实际内存大。</li>
<li>内存保护。每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。</li>
<li>公平分配内存。每个进程都相当于有同样大小的虚存空间。</li>
<li>当进行需要通信室，可以采用虚拟内存来实现。</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要建立很多数据结构，占用额外内存。</li>
<li>虚拟地址到物理地址的转换，增加了指令执行时间。</li>
<li>页面的换入换出需要磁盘IO，很耗时间。</li>
<li>如果一页中只有一部分数据，会浪费内存。</li>
</ol>
<h3 id="首次适应算法-最佳适应算法-最坏适应算法"><a href="#首次适应算法-最佳适应算法-最坏适应算法" class="headerlink" title="首次适应算法-最佳适应算法-最坏适应算法"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34777600/article/details/79507681">首次适应算法-最佳适应算法-最坏适应算法</a></h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/cc758b0f8c784741805d9b9dd8b0e5a8">题目</a></p>
<ul>
<li>首次适应算法（first-fit）：<br>从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法的目的在于减少查找时间。</li>
<li>最佳适应算法（best-fit）：<br>从全部空闲区中找出能满足作业要求的，且大小最小的空闲分区，这种方法能使碎片尽量小。</li>
<li>最差适应算法（worst-fit）：<br>它从全部空闲区中找出能满足作业要求的、且大小最大的空闲分区，从而使链表中的节点大小趋于均匀。</li>
</ul>
<h3 id="缺页中断-FIFO、LRU、OPT三种置换算法"><a href="#缺页中断-FIFO、LRU、OPT三种置换算法" class="headerlink" title="缺页中断-FIFO、LRU、OPT三种置换算法"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011080472/article/details/51206332">缺页中断-FIFO、LRU、OPT三种置换算法</a></h3><ul>
<li>最佳置换（OPT）<br>置换以后不再被访问，或者在将来最迟才回被访问的页面，缺页中断率最低。但是该算法需要依据以后各业的使用情况，而当一个进程还未运行完成是，很难估计哪一个页面是以后不再使用或在最长时间以后才会用到的页面。所以<strong>该算法是不能实现的</strong>。但该算法仍然有意义，作为很亮其他算法优劣的一个标准。</li>
<li>先进先出置换算法（First In First Out, FIFO)<br>置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成<strong>队列</strong>，从队尾进入，从队首删除。但是该算法会淘汰经常访问的页面，不适应进程实际运行的规律，目前已经<strong>很少使用</strong>。</li>
<li>最近最久未使用置换算法（Least Recently Used， LRU）<br>置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。<br>LRU算法普偏地适用于各种类型的程序，但是系统要时时刻刻对各页的访问历史情况加以记录和更新，开销太大，因此LRU算法必须要有硬件的支持。</li>
</ul>
<h2 id="用户编程接口"><a href="#用户编程接口" class="headerlink" title="用户编程接口"></a>用户编程接口</h2><h3 id="静态链接和动态链接的不同"><a href="#静态链接和动态链接的不同" class="headerlink" title="静态链接和动态链接的不同"></a>静态链接和动态链接的不同</h3><p>静态链接就是把要调用的函数或者过程直接链接到可执行文件中，成为可执行文件的一部分。函数和代码就在exe中，缺点就是当多个程序调用相同函数时，内存中就会存在这个函数的多个拷贝，浪费了内存资源。</p>
<p>动态链接是相对于静态链接而言的，当当成如被载入内存时，在操作系统的管理下，才在应用程序与DLL之间建立链接关系，当要执行DLL中的函数时，根据链接的重定位信息，转为执行DLL的函数代码。</p>
<h3 id="用户态和核心态"><a href="#用户态和核心态" class="headerlink" title="用户态和核心态"></a>用户态和核心态</h3><h3 id="用户栈与内核栈"><a href="#用户栈与内核栈" class="headerlink" title="用户栈与内核栈"></a>用户栈与内核栈</h3><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>参考文章：<a target="_blank" rel="noopener" href="https://www.hollischuang.com/archives/898">彻底理解数据库事务</a></p>
<ul>
<li><p>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，事务通常就是指数据库事务。</p>
</li>
<li><p>一个数据库事务通常包含对数据库进行读或写的一个操作序列。</p>
<ul>
<li>为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</li>
<li>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</li>
</ul>
<p>当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</p>
<p>但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统&#x2F;操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。</p>
</li>
<li><p>特性（事务应该具有的4个属性）：</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li><strong>一致性（Consistency）</strong>：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。<strong>一致状态的含义是数据库中的数据应满足完整性约束。</strong></li>
<li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li><strong>持久性（Durability）</strong>：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li>
</ul>
<blockquote>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：</p>
<p>1、从A账号中把余额读出来（500）。<br>2、对A账号做减法操作（500-100）。<br>3、把结果写回A账号中（400）。<br>4、从B账号中把余额读出来（500）。<br>5、对B账号做加法操作（500+100）。<br>6、把结果写回B账号中（600）。</p>
<h3 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h3><p>保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>在转账之前，A和B的账户中共有500+500&#x3D;1000元钱。在转账之后，A和B的账户中共有400+600&#x3D;1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。<br>如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！</p>
<h2 id="原子性与隔离行"><a href="#原子性与隔离行" class="headerlink" title="原子性与隔离行"></a>原子性与隔离行</h2><p>一致性与原子性是密切相关的,原子性的破坏可能导致数据库的不一致，数据的一致性问题并不都和原子性有关。<br>比如刚刚的例子，在第五步的时候，对B账户做加法时只加了50元。那么该过程可以符合原子性，但是数据的一致性就出现了问题。</p>
<p>因此，事务的原子性与一致性缺一不可。</p>
</blockquote>
</li>
</ul>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="SQL查询语句执行顺序"><a href="#SQL查询语句执行顺序" class="headerlink" title="SQL查询语句执行顺序"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangzeyuaaa/article/details/21044617">SQL查询语句执行顺序</a></h3><p>注意是执行顺序，而不是写法。写法如下，执行顺序已标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--查询组合字段</span><br><span class="line">(5)select (5-2) distinct(5-3) top(&lt;top_specification&gt;)(5-1)&lt;select_list&gt;</span><br><span class="line">--连表</span><br><span class="line">(1)from (1-J)&lt;left_table&gt;&lt;join_type&gt; join &lt;right_table&gt; on &lt;on_predicate&gt;</span><br><span class="line">        (1-A)&lt;left_table&gt;&lt;apply_type&gt; apply &lt;right_table_expression&gt; as &lt;alias&gt;</span><br><span class="line">        (1-P)&lt;left_table&gt; pivot (&lt;pivot_specification&gt;) as &lt;alias&gt;</span><br><span class="line">        (1-U)&lt;left_table&gt; unpivot (&lt;unpivot_specification&gt;) as &lt;alias&gt;</span><br><span class="line">--查询条件</span><br><span class="line">(2)where &lt;where_pridicate&gt;</span><br><span class="line">--分组</span><br><span class="line">(3)group by &lt;group_by_specification&gt;</span><br><span class="line">--分组条件</span><br><span class="line">(4)having&lt;having_predicate&gt;</span><br><span class="line">--排序</span><br><span class="line">(6)order by&lt;order_by_list&gt;</span><br></pre></td></tr></table></figure>

<h3 id="脏读、幻读、不可重复读-事务隔离级别-SQL-Server"><a href="#脏读、幻读、不可重复读-事务隔离级别-SQL-Server" class="headerlink" title="脏读、幻读、不可重复读 + 事务隔离级别+SQL Server"></a><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/uule-1109647">脏读、幻读、不可重复读 + 事务隔离级别+SQL Server</a></h3><ul>
<li><p><strong>脏读</strong>：</p>
<p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</p>
</li>
<li><p><strong>不可重复读</strong>：<br>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。<br>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
</li>
<li><p><strong>幻读</strong>：<br>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a><strong>隔离级别</strong></h4><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（Read uncommitted）</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>已提交读（Read committed）</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读（Repeatable read）</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可串行化（Serializable）</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<ul>
<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li>
<li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li>
<li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</li>
<li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ul>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><ul>
<li><p>悲观锁</p>
<p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）<br>在数据库中，悲观锁的流程是：</p>
<ol>
<li>在对任意记录进行修改前，先尝试为该记录加上<a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/923">排他锁</a>（exclusive locking）。</li>
<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>
</ol>
<p>优缺点：<br>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</p>
</li>
<li><p>乐观锁</p>
<p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>
<p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。<br>数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</p>
</li>
</ul>
<p>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。</p>
<p>1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</p>
<p>2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</p>
<p>随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>太真实了，面试官问的专业名词听都没听过。</p>
<p><strong>公平锁就是保障了多线程下各线程获取锁的顺序，先到的线程优先获取锁，而非公平锁则无法提供这个保障。</strong></p>
<p>图转载自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f584799f1c77">https://www.jianshu.com/p/f584799f1c77</a></p>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509817/blog/jl05hklsjpemtfqdngm8.jpg" alt="公平锁与非公平锁"></p>
<h3 id="共享锁与排它锁"><a href="#共享锁与排它锁" class="headerlink" title="共享锁与排它锁"></a>共享锁与排它锁</h3><ul>
<li><strong>共享锁【S锁】</strong><br>又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li>
<li><strong>排他锁【X锁】</strong><br>又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li>
</ul>
<h1 id="计算机视觉＆图像处理"><a href="#计算机视觉＆图像处理" class="headerlink" title="计算机视觉＆图像处理"></a>计算机视觉＆图像处理</h1><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liulina603/article/details/52953414">相机标定和相机参数</a><ol>
<li>相机外参 6 个参数：旋转矩阵3个，平移矩阵3个</li>
<li>相机内参：f, k, sx, sy, cx, cy</li>
<li>线阵相机的标定在《机器视觉算法与应用》P258.主要是考虑了运动状态。不做仔细研究了。</li>
</ol>
</li>
<li>标定过程（机器视觉算法与应用P268）<ol>
<li>标定板<ol>
<li>书中和Halcon用的是圆形标定板：平面上有mxn个圆形标志点，标志点们外围有一个黑色矩形边界框，其中某个角落有一个方向标记，用于确定标定板的唯一方向。</li>
<li>张正友标定法用的是棋盘格</li>
</ol>
</li>
<li>过程<ol>
<li>利用黑色矩形框，将内部与背景区分</li>
<li>阈值操作分割，得到各个圆形标志区域</li>
<li>提取边缘，拟合为椭圆，最小外接四边形的中心为投影中心</li>
</ol>
</li>
<li>计算<ol>
<li>标定标记在世界坐标系中坐标为Mi,图像中坐标为mi，摄像机投影模型内外参c。标记要一一对应。用优化问题来求相机参数。但是求解参数过多，没有唯一解。其次，优化问题复杂，最好先用初始化参数进行初始化，比如出厂设置，平面坐标用尺子两个初始值。<br><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509818/blog/zcqqnntqc89udtwdx2cx.png" alt="标定"></li>
<li>容易出现没有唯一解，就要用多幅图像进行标定。同时为了使得参数准确度更高，所有图像中标定板的位置应该能够覆盖图像的四个角，主要是因为角落处镜头畸变最大，这样就可以得到经变系数k最准确的值。<br><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509819/blog/vbvkj0yqrwnqr8cypqt5.png" alt="标定2"></li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.shuxuele.com/data/confidence-interval.html">置信区间计算</a></li>
<li></li>
</ol>
<h3 id="字节跳动面经整理"><a href="#字节跳动面经整理" class="headerlink" title="字节跳动面经整理"></a>字节跳动面经整理</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/241769">https://www.nowcoder.com/discuss/241769</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/238341?type=post&order=time&pos=&page=1&subType=2">https://www.nowcoder.com/discuss/238341?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/238308?type=post&order=time&pos=&page=1&subType=2">https://www.nowcoder.com/discuss/238308?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/235624?type=post&order=time&pos=&page=1&subType=2">https://www.nowcoder.com/discuss/235624?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/227379?type=post&order=time&pos=&page=1&subType=2">https://www.nowcoder.com/discuss/227379?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/207290?type=post&order=time&pos=&page=2&subType=2">https://www.nowcoder.com/discuss/207290?type=post&amp;order=time&amp;pos=&amp;page=2&amp;subType=2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/163590">https://www.nowcoder.com/discuss/163590</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>xiaohai
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://shenxiaohai.me/online-test-summary/" title="总结总结笔试不会的题">https://shenxiaohai.me/online-test-summary/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AF%95/" rel="tag"><i class="fa fa-tag"></i> 笔试</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 计算机基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/codecraft-2019/" rel="prev" title="华为软挑代码开源及思路介绍">
                  <i class="fa fa-chevron-left"></i> 华为软挑代码开源及思路介绍
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/online-algo-summary/" rel="next" title="总结总结数据结构和算法不会的题目">
                  总结总结数据结构和算法不会的题目 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments"><div id="twikoo-comments"></div></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-laptop"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaohai</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/veraposeidon" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://shenxiaohai.me/online-test-summary/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="twikoo" type="application/json">{"enable":true,"visitor":false,"envId":"https://twikoo-comment.shenxiaohai.me/","el":"#twikoo-comments"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.twikoo.el)
    .then(() => NexT.utils.getScript(
      CONFIG.twikoo.jsUrl || 'https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js',
      { condition: window.twikoo }
    ))
    .then(() => {
      twikoo.init(CONFIG.twikoo);
    });
});
</script>
<style>
.post-block, .comments {
  overflow: visible;
}
.tk-owo-emotion {
  display: inline-block;
}
</style>

</body>
</html>
