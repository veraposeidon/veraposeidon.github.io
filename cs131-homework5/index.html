<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.webp" color="#222">
  <meta name="google-site-verification" content="Cj9oDgXxdJe6MoA_lEUQ2rmOouwJeTm5uJNqjhOv8Ng">
  <meta name="msvalidate.01" content="E5D0AA8F5E012DFD9C5F3954DF8283B1">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenxiaohai.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"twikoo","storage":true,"lazyload":false,"nav":null,"activeClass":"twikoo"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="CS131 Computer Vision： Foundations and Applications，Homework5：Segmentation-Clustering。 实现聚类算法：K-Means和HAC(凝聚聚类算法)；构建图像的特征序列，进行聚类分割；实现分割结果与GroundTruth的量化评估，根据指标评估聚类算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="CS131,Homewrok5,Segmentation-Clustering">
<meta property="og:url" content="https://shenxiaohai.me/cs131-homework5/index.html">
<meta property="og:site_name" content="SHEN&#39;s DevNotes">
<meta property="og:description" content="CS131 Computer Vision： Foundations and Applications，Homework5：Segmentation-Clustering。 实现聚类算法：K-Means和HAC(凝聚聚类算法)；构建图像的特征序列，进行聚类分割；实现分割结果与GroundTruth的量化评估，根据指标评估聚类算法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509768/blog/ayemivuoz2augi8wbq8c.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509769/blog/fvqhpezql6aj1wdzbws3.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509770/blog/jfvgyur6zp2ogrdga7lb.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509770/blog/ffwyfghpkvdesh9bbn4v.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509771/blog/ucjj70evjms6xzqilcgk.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509772/blog/cjjcffxvdr3utmgcy7rw.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509773/blog/ulqvv0dsg13svbzgyyyv.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509773/blog/lshy7rgxig6kgrkeqhsn.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509774/blog/i0ofz0pesbqrorevtnnu.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509774/blog/zgzciv1op7zbzwfmsath.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509775/blog/ummjvxytyq4rijv0boou.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509775/blog/zmtga2uwktiw2piunwfh.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509776/blog/yapov9ep5ttcf6vw58ne.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509777/blog/mxdlcstiqvbi0vntu4lt.png">
<meta property="og:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509777/blog/dbxajyk1i2azmjnthrb0.png">
<meta property="article:published_time" content="2018-09-11T10:14:34.000Z">
<meta property="article:modified_time" content="2023-03-11T05:02:28.498Z">
<meta property="article:author" content="xiaohai">
<meta property="article:tag" content="计算机视觉">
<meta property="article:tag" content="CS131">
<meta property="article:tag" content="图像分割">
<meta property="article:tag" content="聚类算法">
<meta property="article:tag" content="K-Means">
<meta property="article:tag" content="HAC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509768/blog/ayemivuoz2augi8wbq8c.png">


<link rel="canonical" href="https://shenxiaohai.me/cs131-homework5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://shenxiaohai.me/cs131-homework5/","path":"cs131-homework5/","title":"CS131,Homewrok5,Segmentation-Clustering"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CS131,Homewrok5,Segmentation-Clustering | SHEN's DevNotes</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YDT7F4NZP6"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-YDT7F4NZP6","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="SHEN's DevNotes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SHEN's DevNotes</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习笔记，编程技巧，效率工具</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">135</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">74</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Homework-5"><span class="nav-text">Homework 5</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Clustering-Algorithms-40-points"><span class="nav-text">1 Clustering Algorithms (40 points)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-K-Means-Clustering-20-points"><span class="nav-text">1.1 K-Means Clustering (20 points)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Hierarchical-Agglomerative-Clustering-20-points"><span class="nav-text">1.2 Hierarchical Agglomerative Clustering (20 points)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Pixel-Level-Features-30-points"><span class="nav-text">2 Pixel-Level Features (30 points)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Color-Features-15-points"><span class="nav-text">2.1 Color Features (15 points)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Color-and-Position-Features-15-points"><span class="nav-text">2.2 Color and Position Features (15 points)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Extra-Credit-Implement-Your-Own-Feature"><span class="nav-text">Extra Credit: Implement Your Own Feature</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Quantitative-Evaluation-30-points"><span class="nav-text">3 Quantitative Evaluation (30 points)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%A3%E6%A1%88"><span class="nav-text">代码档案</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaohai</p>
  <div class="site-description" itemprop="description">我在这个技术博客中分享学习笔记，提供实用技巧和工具资源。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">135</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/veraposeidon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;veraposeidon" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/HiYoake" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;HiYoake" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shenxiaohai.me/cs131-homework5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaohai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHEN's DevNotes">
      <meta itemprop="description" content="我在这个技术博客中分享学习笔记，提供实用技巧和工具资源。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CS131,Homewrok5,Segmentation-Clustering | SHEN's DevNotes">
      <meta itemprop="description" content="CS131 Computer Vision： Foundations and Applications，Homework5：Segmentation-Clustering。<br> 实现聚类算法：K-Means和HAC(凝聚聚类算法)；构建图像的特征序列，进行聚类分割；实现分割结果与GroundTruth的量化评估，根据指标评估聚类算法。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CS131,Homewrok5,Segmentation-Clustering
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-11 10:14:34" itemprop="dateCreated datePublished" datetime="2018-09-11T10:14:34Z">2018-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 05:02:28" itemprop="dateModified" datetime="2023-03-11T05:02:28Z">2023-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">CS131 Computer Vision： Foundations and Applications，Homework5：Segmentation-Clustering。<br> 实现聚类算法：K-Means和HAC(凝聚聚类算法)；构建图像的特征序列，进行聚类分割；实现分割结果与GroundTruth的量化评估，根据指标评估聚类算法。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Homework-5"><a href="#Homework-5" class="headerlink" title="Homework 5"></a>Homework 5</h1><p><em>This notebook includes both coding and written questions. Please hand in this notebook file with all the outputs and your answers to the written questions.</em></p>
<p>This assignment covers K-Means and HAC methods for clustering.</p>
<p>这份作业包含的主题：用于聚类的K-means 和 HAC（层次凝聚聚类）方法，以及聚类算法的量化评估。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Setup</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> rc</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = (<span class="number">15.0</span>, <span class="number">12.0</span>) <span class="comment"># set default size of plots</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;image.interpolation&#x27;</span>] = <span class="string">&#x27;nearest&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;image.cmap&#x27;</span>] = <span class="string">&#x27;gray&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for auto-reloading extenrnal modules</span></span><br><span class="line">%load_ext autoreload</span><br><span class="line">%autoreload <span class="number">2</span></span><br></pre></td></tr></table></figure>

<pre><code>The autoreload extension is already loaded. To reload it, use:
  %reload_ext autoreload
</code></pre>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In this assignment, you will use clustering algorithms to segment images. You will then use these segmentations to identify foreground and background objects.</p>
<p>Your assignment will involve the following subtasks:</p>
<ul>
<li><strong>Clustering algorithms</strong>: Implement K-Means clustering and Hierarchical Agglomerative Clustering.</li>
<li><strong>Pixel-level features</strong>: Implement a feature vector that combines color and position information and implement feature normalization.</li>
<li><strong>Quantitative Evaluation</strong>: Evaluate segmentation algorithms with a variety of parameter settings by comparing your computed segmentations against a dataset of ground-truth segmentations.</li>
</ul>
<p>使用聚类算法实现图像分割，分割图像前景和背景。</p>
<p>作业分为这三步：</p>
<ol>
<li>聚类算法的实现：实现K-Means聚类和层次凝聚聚类</li>
<li>像素级特征：实现结合颜色和位置信息的特征向量以及实现特征归一化。</li>
<li>量化评估：通过将计算出来的分割结果与GroundTruth进行比较，评估具有各种参数设置的分割算法。</li>
</ol>
<p><strong>量化评估这一块重要，我还没学过评估分割结果的方法</strong></p>
<h2 id="1-Clustering-Algorithms-40-points"><a href="#1-Clustering-Algorithms-40-points" class="headerlink" title="1 Clustering Algorithms (40 points)"></a>1 Clustering Algorithms (40 points)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generate random data points for clustering</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster 1</span></span><br><span class="line">mean1 = [-<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">cov1 = [[<span class="number">0.1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.1</span>]]</span><br><span class="line">X1 = np.random.multivariate_normal(mean1, cov1, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster 2</span></span><br><span class="line">mean2 = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">cov2 = [[<span class="number">0.1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.1</span>]]</span><br><span class="line">X2 = np.random.multivariate_normal(mean2, cov2, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster 3</span></span><br><span class="line">mean3 = [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">cov3 = [[<span class="number">0.1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.1</span>]]</span><br><span class="line">X3 = np.random.multivariate_normal(mean3, cov3, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster 4</span></span><br><span class="line">mean4 = [<span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line">cov4 = [[<span class="number">0.1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.1</span>]]</span><br><span class="line">X4 = np.random.multivariate_normal(mean4, cov4, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Merge two sets of data points</span></span><br><span class="line">X = np.concatenate((X1, X2, X3, X4))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot data points</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>])</span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509768/blog/ayemivuoz2augi8wbq8c.png" alt="png"></p>
<h3 id="1-1-K-Means-Clustering-20-points"><a href="#1-1-K-Means-Clustering-20-points" class="headerlink" title="1.1 K-Means Clustering (20 points)"></a>1.1 K-Means Clustering (20 points)</h3><p>As discussed in class, K-Means is one of the most popular clustering algorithms. We have provided skeleton code for K-Means clustering in the file <code>segmentation.py</code>. Your first task is to finish implementing <strong><code>kmeans</code></strong> in <code>segmentation.py</code>. This version uses nested for loops to assign points to the closest centroid and compute new mean of each cluster.</p>
<blockquote>
<p><strong>K-Means Wiki</strong></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/K-%E5%B9%B3%E5%9D%87%E7%AE%97%E6%B3%95">k-平均算法</a></p>
</blockquote>
<p>目前题图允许使用循环实现点到最近中心的分配即可。</p>
<p>K-means的步骤：</p>
<ol>
<li>随机初始化聚类中心</li>
<li>将点分配给最近的中心</li>
<li>计算每个聚类的新的中心</li>
<li>如果聚类的分配不再变动则停止</li>
<li>从第二步继续循环</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> segmentation <span class="keyword">import</span> kmeans</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">start = time()</span><br><span class="line">assignments = kmeans(X, <span class="number">4</span>)</span><br><span class="line">end = time()</span><br><span class="line"></span><br><span class="line">kmeans_runtime = end - start</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;kmeans running time: %f seconds.&quot;</span> % kmeans_runtime)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    cluster_i = X[assignments==i]</span><br><span class="line">    plt.scatter(cluster_i[:, <span class="number">0</span>], cluster_i[:, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>迭代次数 8
kmeans running time: 0.061108 seconds.
</code></pre>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509769/blog/fvqhpezql6aj1wdzbws3.png" alt="png"></p>
<p><strong>哈，简单的实现了K-Means算法，发现第三步判断终止条件很重要，添加了以后只迭代了几次就结束了，大大降低了运行时间。</strong></p>
<p>We can use numpy functions and broadcasting to make kmeans faster. Implement <strong><code>kmeans_fast</code></strong> in <code>segmentation.py</code>. This should run at least 10 times faster than the previous implementation.</p>
<p>又是加快运算速度的老要求。</p>
<p>想想思路：</p>
<ul>
<li>题目的提示是使用numpy函数和broadcasting机制</li>
<li>np.repeat and np.argmin 有帮助</li>
<li>还有一种思路就是向量化了，不做迭代而是放在矩阵里去计算。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> segmentation <span class="keyword">import</span> kmeans_fast</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">start = time()</span><br><span class="line">assignments = kmeans_fast(X, <span class="number">4</span>)</span><br><span class="line">end = time()</span><br><span class="line"></span><br><span class="line">kmeans_fast_runtime = end - start</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;kmeans running time: %f seconds.&quot;</span> % kmeans_fast_runtime)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%f times faster!&quot;</span> % (kmeans_runtime / kmeans_fast_runtime))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    cluster_i = X[assignments==i]</span><br><span class="line">    plt.scatter(cluster_i[:, <span class="number">0</span>], cluster_i[:, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>kmeans running time: 0.003889 seconds.
15.714531 times faster!
</code></pre>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509770/blog/jfvgyur6zp2ogrdga7lb.png" alt="png"></p>
<p><strong>快了十六倍 ，666，向量化是个好东西！！！</strong></p>
<h3 id="1-2-Hierarchical-Agglomerative-Clustering-20-points"><a href="#1-2-Hierarchical-Agglomerative-Clustering-20-points" class="headerlink" title="1.2 Hierarchical Agglomerative Clustering (20 points)"></a>1.2 Hierarchical Agglomerative Clustering (20 points)</h3><p>Another simple clustering algorithm is Hieararchical Agglomerative Clustering, which is somtimes abbreviated as HAC. In this algorithm, each point is initially assigned to its own cluster. Then cluster pairs are merged until we are left with the desired number of predetermined clusters (see Algorithm 1).</p>
<p>Implement <strong><code>hiererachical_clustering</code></strong> in <code>segmentation.py</code>.</p>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509770/blog/ffwyfghpkvdesh9bbn4v.png" alt="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509770/blog/ffwyfghpkvdesh9bbn4v.png"></p>
<p>按照上图的算法定义是：</p>
<ol>
<li>初始化每个点为一个簇</li>
<li>迭代直到只剩下K个簇：<ul>
<li>计算所有簇与簇之间（簇对）的距离</li>
<li>合并最近的两个簇</li>
</ul>
</li>
</ol>
<p>这个算法的关键，主要是如何定义簇与簇之间的距离。定义有下面三种：</p>
<ul>
<li>1）单链（Single-link）：不同两个聚类中离得最近的两个点之间的距离，即MIN；</li>
<li>2）全链（Complete-link）：不同两个聚类中离得最远的两个点之间的距离，即MAX；</li>
<li>3）平均链（Average-link）：不同两个聚类中所有点对距离的平均值，即AVERAGE；</li>
</ul>
<p>题目代码中提示的做法是，利用簇中心的欧几里得距离来定义簇与簇之间的距离。</p>
<p>hierarchical_clustering函数将按照这个思路实现。</p>
<blockquote>
<p>** 博客推荐 **</p>
<p>Numpy中的距离度量函数</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/denny402/p/7027954.html">距离度量以及python实现(一)</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> segmentation <span class="keyword">import</span> hierarchical_clustering</span><br><span class="line"></span><br><span class="line">start = time()</span><br><span class="line">assignments = hierarchical_clustering(X, <span class="number">4</span>)</span><br><span class="line">end = time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hierarchical_clustering running time: %f seconds.&quot;</span> % (end - start))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    cluster_i = X[assignments==i]</span><br><span class="line">    plt.scatter(cluster_i[:, <span class="number">0</span>], cluster_i[:, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>hierarchical_clustering running time: 0.191211 seconds.
</code></pre>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509771/blog/ucjj70evjms6xzqilcgk.png" alt="png"></p>
<p>运行时间比预期的块，总结一下就是这类算法的提速方式：</p>
<ul>
<li>第一个是善用向量化，用矩阵来计算问题</li>
<li>第二个就是善用numpy提供的函数，解决一些需要搜索遍历的问题</li>
</ul>
<h2 id="2-Pixel-Level-Features-30-points"><a href="#2-Pixel-Level-Features-30-points" class="headerlink" title="2 Pixel-Level Features (30 points)"></a>2 Pixel-Level Features (30 points)</h2><p>Before we can use a clustering algorithm to segment an image, we must compute some <em>feature vectore</em> for each pixel. The feature vector for each pixel should encode the qualities that we care about in a good segmentation. More concretely, for a pair of pixels $p_i$ and $p_j$ with corresponding feature vectors $f_i$ and $f_j$, the distance between $f_i$ and $f_j$ should be small if we believe that $p_i$ and $p_j$ should be placed in the same segment and large otherwise.</p>
<p>上一步的聚类算法实现其实是流程的第二步，第一步其实是特征的提取，有了特征才能进行像素（或者说样本）的聚类。只不过第一步中，拿了点的位置作为特征来进行聚类了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load and display image</span></span><br><span class="line">img = io.imread(<span class="string">&#x27;train.jpg&#x27;</span>)</span><br><span class="line">H, W, C = img.shape</span><br><span class="line"></span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509772/blog/cjjcffxvdr3utmgcy7rw.png" alt="png"></p>
<h3 id="2-1-Color-Features-15-points"><a href="#2-1-Color-Features-15-points" class="headerlink" title="2.1 Color Features (15 points)"></a>2.1 Color Features (15 points)</h3><p>One of the simplest possible feature vectors for a pixel is simply the vector of colors for that pixel. Implement <strong><code>color_features</code></strong> in <code>segmentation.py</code>. Output should look like the following:<br><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509773/blog/ulqvv0dsg13svbzgyyyv.png" alt="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509773/blog/ulqvv0dsg13svbzgyyyv.png"></p>
<p>在color_features实现简单的颜色特征的聚类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> segmentation <span class="keyword">import</span> color_features</span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">features = color_features(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sanity checks</span></span><br><span class="line"><span class="keyword">assert</span> features.shape == (H * W, C),\</span><br><span class="line">    <span class="string">&quot;Incorrect shape! Check your implementation.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> features.dtype == np.<span class="built_in">float</span>,\</span><br><span class="line">    <span class="string">&quot;dtype of color_features should be float.&quot;</span></span><br><span class="line"></span><br><span class="line">assignments = kmeans_fast(features, <span class="number">8</span>)</span><br><span class="line">segments = assignments.reshape((H, W))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display segmentation</span></span><br><span class="line">plt.imshow(segments, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509773/blog/lshy7rgxig6kgrkeqhsn.png" alt="png"></p>
<p>In the cell below, we visualize each segment as the mean color of pixels in the segment.</p>
<p>将聚类结果用颜色进行显示（颜色是指源图各个分割区域内的颜色均值）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> visualize_mean_color_image</span><br><span class="line">visualize_mean_color_image(img, segments)</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509774/blog/i0ofz0pesbqrorevtnnu.png" alt="png"></p>
<h3 id="2-2-Color-and-Position-Features-15-points"><a href="#2-2-Color-and-Position-Features-15-points" class="headerlink" title="2.2 Color and Position Features (15 points)"></a>2.2 Color and Position Features (15 points)</h3><p>Another simple feature vector for a pixel is to concatenate its color and position within the image. In other words, for a pixel of color $(r, g, b)$ located at position $(x, y)$ in the image, its feature vector would be $(r, g, b, x, y)$. However, the color and position features may have drastically different ranges; for example each color channel of an image may be in the range $[0, 1)$, while the position of each pixel may have a much wider range. Uneven scaling between different features in the feature vector may cause clustering algorithms to behave poorly.</p>
<p>One way to correct for uneven scaling between different features is to apply some sort of normalization to the feature vector. One of the simplest types of normalization is to force each feature to have zero mean and unit variance.</p>
<p>Implement <strong><code>color_position_features</code></strong> in <code>segmentation.py</code>.</p>
<p>Output segmentation should look like the following:<br><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509774/blog/zgzciv1op7zbzwfmsath.png" alt="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509774/blog/zgzciv1op7zbzwfmsath.png"></p>
<p><strong>结合颜色特征和位置特征的聚类</strong></p>
<p>其实就是生成特征为  $(r,g,b,x,y)$的序列，但需要考虑的问题是尺度的不同，解决的方案也很简单，就是进行归一化，对每一个维度进行归一化。公式如下：<br>$$<br>feature_{new} &#x3D; \frac{(feature - Mean(feature))}{Std (feature)}<br>$$</p>
<blockquote>
<p><strong>知识点补充</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn15698845876/article/details/73380803">Numpy中stack()，hstack()，vstack()函数详解</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> segmentation <span class="keyword">import</span> color_position_features</span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">features = color_position_features(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sanity checks</span></span><br><span class="line"><span class="keyword">assert</span> features.shape == (H * W, C + <span class="number">2</span>),\</span><br><span class="line">    <span class="string">&quot;Incorrect shape! Check your implementation.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> features.dtype == np.<span class="built_in">float</span>,\</span><br><span class="line">    <span class="string">&quot;dtype of color_features should be float.&quot;</span></span><br><span class="line"></span><br><span class="line">assignments = kmeans_fast(features, <span class="number">8</span>)</span><br><span class="line">segments = assignments.reshape((H, W))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display segmentation</span></span><br><span class="line">plt.imshow(segments, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509775/blog/ummjvxytyq4rijv0boou.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visualize_mean_color_image(img, segments)</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509775/blog/zmtga2uwktiw2piunwfh.png" alt="png"></p>
<h3 id="Extra-Credit-Implement-Your-Own-Feature"><a href="#Extra-Credit-Implement-Your-Own-Feature" class="headerlink" title="Extra Credit: Implement Your Own Feature"></a>Extra Credit: Implement Your Own Feature</h3><p>For this programming assignment we have asked you to implement a very simple feature transform for each pixel. While it is not required, you should feel free to experiment with other feature transforms. Could your final segmentations be improved by adding gradients, edges, SIFT descriptors, or other information to your feature vectors? Could a different type of normalization give better results?</p>
<p>Implement your feature extractor <strong><code>my_features</code></strong> in <code>segmentation.py</code></p>
<p>Depending on the creativity of your approach and the quality of your writeup, implementing extra feature vectors can be worth extra credit (up to 5% of total points).</p>
<p><strong>Describe your approach</strong>: (YOUR APPROACH)</p>
<p><strong>实现自己定义的特征</strong></p>
<p>可以实现一些简单的特征，比如添加梯度、边缘、SIFT描述子或者其他信息。</p>
<p>我添加了一个梯度强度信息，结合颜色特征，位置特征。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> segmentation <span class="keyword">import</span> my_features</span><br><span class="line"></span><br><span class="line"><span class="comment"># Feel free to experiment with different images</span></span><br><span class="line"><span class="comment"># and varying number of segments</span></span><br><span class="line">img = io.imread(<span class="string">&#x27;train.jpg&#x27;</span>)</span><br><span class="line">num_segments = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">H, W, C = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract pixel-level features</span></span><br><span class="line">features = my_features(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run clustering algorithm</span></span><br><span class="line">assignments = kmeans_fast(features, num_segments)</span><br><span class="line"></span><br><span class="line">segments = assignments.reshape((H, W))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display segmentation</span></span><br><span class="line">plt.imshow(segments, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509776/blog/yapov9ep5ttcf6vw58ne.png" alt="png"></p>
<p>效果看上去还可以，就是后面的量化评估并没有好成绩。</p>
<h2 id="3-Quantitative-Evaluation-30-points"><a href="#3-Quantitative-Evaluation-30-points" class="headerlink" title="3 Quantitative Evaluation (30 points)"></a>3 Quantitative Evaluation (30 points)</h2><p>Looking at images is a good way to get an idea for how well an algorithm is working, but the best way to evaluate an algorithm is to have some quantitative measure of its performance.</p>
<p>For this project we have supplied a small dataset of cat images and ground truth segmentations of these images into foreground (cats) and background (everything else). We will quantitatively evaluate different segmentation methods (features and clustering methods) on this dataset.</p>
<p>We can cast the segmentation task into a binary classification problem, where we need to classify each pixel in an image into either foreground (positive) or background (negative). Given the ground-truth labels, the accuracy of a segmentation is $(TP+TN)&#x2F;(P+N)$.</p>
<p>Implement <strong><code>compute_accuracy</code></strong> in <code>segmentation.py</code>.</p>
<p>实现准确率计算就是正确个数与总个数之比。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> segmentation <span class="keyword">import</span> compute_accuracy</span><br><span class="line"></span><br><span class="line">mask_gt = np.zeros((<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">mask = np.zeros((<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Test compute_accracy function</span></span><br><span class="line">mask_gt[<span class="number">20</span>:<span class="number">50</span>, <span class="number">30</span>:<span class="number">60</span>] = <span class="number">1</span></span><br><span class="line">mask[<span class="number">30</span>:<span class="number">50</span>, <span class="number">30</span>:<span class="number">60</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">accuracy = compute_accuracy(mask_gt, mask)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Accuracy: %0.2f&#x27;</span> % (accuracy))</span><br><span class="line"><span class="keyword">if</span> accuracy != <span class="number">0.97</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Check your implementation!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(mask_gt)</span><br><span class="line">plt.title(<span class="string">&#x27;Ground Truth&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(mask)</span><br><span class="line">plt.title(<span class="string">&#x27;Estimate&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>Accuracy: 0.97
</code></pre>
<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509777/blog/mxdlcstiqvbi0vntu4lt.png" alt="png"></p>
<p>You can use the script below to evaluate a segmentation method’s ability to separate foreground from background on the entire provided dataset. Use this script as a starting point to evaluate a variety of segmentation parameters.</p>
<p>下面这段程序是已经完成的，主要逻辑就是</p>
<ol>
<li>加载数据集，包括原图和分割结果真值</li>
<li>调用之前实现的聚类分割算法进行分割</li>
<li>将真值和分割结果进行比对，计算准确率</li>
</ol>
<p>可以在下面进行调参，更改参数，查看效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> load_dataset, compute_segmentation</span><br><span class="line"><span class="keyword">from</span> segmentation <span class="keyword">import</span> evaluate_segmentation,my_features</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load a small segmentation dataset</span></span><br><span class="line">imgs, gt_masks = load_dataset(<span class="string">&#x27;./data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the parameters for segmentation.</span></span><br><span class="line">num_segments = <span class="number">3</span></span><br><span class="line">clustering_fn = kmeans_fast  <span class="comment">#hierarchical_clustering </span></span><br><span class="line">feature_fn = color_position_features <span class="comment"># color_features #color_position_features # my_features</span></span><br><span class="line">scale =<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">mean_accuracy = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">segmentations = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (img, gt_mask) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(imgs, gt_masks)):</span><br><span class="line">    <span class="comment"># Compute a segmentation for this image</span></span><br><span class="line">    segments = compute_segmentation(img, num_segments,</span><br><span class="line">                                    clustering_fn=clustering_fn,</span><br><span class="line">                                    feature_fn=feature_fn,</span><br><span class="line">                                    scale=scale)</span><br><span class="line">    </span><br><span class="line">    segmentations.append(segments)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Evaluate segmentation</span></span><br><span class="line">    accuracy = evaluate_segmentation(gt_mask, segments)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Accuracy for image %d: %0.4f&#x27;</span> %(i, accuracy))</span><br><span class="line">    mean_accuracy += accuracy</span><br><span class="line">    </span><br><span class="line">mean_accuracy = mean_accuracy / <span class="built_in">len</span>(imgs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Mean accuracy: %0.4f&#x27;</span> % mean_accuracy)</span><br></pre></td></tr></table></figure>

<pre><code>/home/ubuntu/anaconda3/lib/python3.6/site-packages/skimage/transform/_warps.py:84: UserWarning: The default mode, &#39;constant&#39;, will be changed to &#39;reflect&#39; in skimage 0.15.
  warn(&quot;The default mode, &#39;constant&#39;, will be changed to &#39;reflect&#39; in &quot;


Accuracy for image 0: 0.8330
Accuracy for image 1: 0.9221
Accuracy for image 2: 0.9859
Accuracy for image 3: 0.8517
Accuracy for image 4: 0.6973
Accuracy for image 5: 0.7073
Accuracy for image 6: 0.6290
Accuracy for image 7: 0.5707
Accuracy for image 8: 0.9028
Accuracy for image 9: 0.9225
Accuracy for image 10: 0.8701
Accuracy for image 11: 0.6352
Accuracy for image 12: 0.8259
Accuracy for image 13: 0.6570
Accuracy for image 14: 0.7508
Accuracy for image 15: 0.6221
Mean accuracy: 0.7740
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visualize segmentation results</span></span><br><span class="line"></span><br><span class="line">N = <span class="built_in">len</span>(imgs)</span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">60</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line"></span><br><span class="line">    plt.subplot(N, <span class="number">3</span>, (i * <span class="number">3</span>) + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(imgs[i])</span><br><span class="line">    plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(N, <span class="number">3</span>, (i * <span class="number">3</span>) + <span class="number">2</span>)</span><br><span class="line">    plt.imshow(gt_masks[i])</span><br><span class="line">    plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(N, <span class="number">3</span>, (i * <span class="number">3</span>) + <span class="number">3</span>)</span><br><span class="line">    plt.imshow(segmentations[i], cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">    plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://res.cloudinary.com/dgchmgebr/image/upload/v1678509777/blog/dbxajyk1i2azmjnthrb0.png" alt="png"></p>
<p>Include a detailed evaluation of the effect of varying segmentation parameters (feature transform, clustering method, number of clusters, resize) on the mean accuracy of foreground-background segmentations on the provided dataset. You should test a minimum of 10 combinations of parameters. To present your results, add rows to the table below (you may delete the first row).</p>
 <table style="width:100%">
  <tr>
    <th>Feature Transform</th>
    <th>Clustering Method</th>
    <th>Number of segments</th>
    <th>Scale</th>
    <th>Mean Accuracy</th>
  </tr>
  <tr>
    <td>Color</td>
    <td>K-Means</td>
    <td>3</td>
    <td>0.5</td>
    <td>0.7979</td>
  </tr>
  <tr>
    <td>Color</td>
    <td>K-Means</td>
    <td>4</td>
    <td>0.5</td>
    <td>0.7664</td>
  </tr>
  <tr>
    <td>Color</td>
    <td>K-Means</td>
    <td>2</td>
    <td>0.5</td>
    <td>0.7609</td>
  </tr>
  <tr>
    <td>Color</td>
    <td>K-Means</td>
    <td>3</td>
    <td>0.4</td>
    <td>0.7904</td>
  </tr>
  <tr>
    <td>Color</td>
    <td>K-Means</td>
    <td>3</td>
    <td>0.6</td>
    <td>0.7935</td>
  </tr>
  <tr>
    <td>Color</td>
    <td>K-Means</td>
    <td>3</td>
    <td>0.8</td>
    <td>0.7963</td>
  </tr>
  <tr>
    <td>Color</td>
    <td>K-Means</td>
    <td>3</td>
    <td>1</td>
    <td>0.7974</td>
  </tr>
  <tr>
    <td>Color-Postion</td>
    <td>K-Means</td>
    <td>3</td>
    <td>1</td>
    <td>0.7767</td>
  </tr>
  <tr>
    <td>Color-Postion</td>
    <td>K-Means</td>
    <td>3</td>
    <td>0.5</td>
    <td>0.7883</td>
  </tr>
   <tr>
    <td>...</td>
    <td>...</td>
    <td>...</td>
    <td>...</td>
    <td>...</td>
  </tr>
    
</table> 

<p>Observe your results carefully and try to answer the following question:</p>
<ol>
<li>Based on your quantitative experiments, how do each of the segmentation parameters affect the quality of the final foreground-background segmentation?</li>
<li>Are some images simply more difficult to segment correctly than others? If so, what are the qualities of these images that cause the segmentation algorithms to perform poorly?</li>
<li>Also feel free to point out or discuss any other interesting observations that you made.</li>
</ol>
<p>Write your analysis in the cell below.</p>
<p><strong>Your answer here</strong>:</p>
<ol>
<li><p>基于对结果的观察：</p>
<ol>
<li>基于颜色-位置特征的聚类效果比基于颜色特征的聚类效果差</li>
<li>聚类数目3个就是最好的了，增大减小都影响效果</li>
<li>尺度是越接近原图，也就是越接近1，准确度越高</li>
</ol>
</li>
<li><p>的确存在一些图更难识别。这些图的一些特性包括</p>
<ol>
<li>背景较为复杂</li>
<li>前景颜色、亮度都与背景较为接近</li>
</ol>
</li>
<li><p>我发现在基于颜色-位置特征的聚类中，尺度并不是越大越好，可能是我做的实验次数不够多。</p>
</li>
</ol>
<h1 id="代码档案"><a href="#代码档案" class="headerlink" title="代码档案"></a>代码档案</h1><p><a target="_blank" rel="noopener" href="https://github.com/StanfordVL/CS131_release/tree/master/hw5_release">官方Repo作业材料</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/veraposeidon/CS131_Assignments/tree/master/hw5_release">个人Repo作业存档</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>xiaohai
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://shenxiaohai.me/cs131-homework5/" title="CS131,Homewrok5,Segmentation-Clustering">https://shenxiaohai.me/cs131-homework5/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" rel="tag"><i class="fa fa-tag"></i> 计算机视觉</a>
              <a href="/tags/CS131/" rel="tag"><i class="fa fa-tag"></i> CS131</a>
              <a href="/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/" rel="tag"><i class="fa fa-tag"></i> 图像分割</a>
              <a href="/tags/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 聚类算法</a>
              <a href="/tags/K-Means/" rel="tag"><i class="fa fa-tag"></i> K-Means</a>
              <a href="/tags/HAC/" rel="tag"><i class="fa fa-tag"></i> HAC</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/cs131-homework4/" rel="prev" title="CS131,Homewrok4,Resizing-SeamCarving">
                  <i class="fa fa-chevron-left"></i> CS131,Homewrok4,Resizing-SeamCarving
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/cs131-homework6/" rel="next" title="CS131,Homewrok6,Recognition-Classification">
                  CS131,Homewrok6,Recognition-Classification <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments"><div id="twikoo-comments"></div></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-laptop"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaohai</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/veraposeidon" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://shenxiaohai.me/cs131-homework5/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="twikoo" type="application/json">{"enable":true,"visitor":false,"envId":"https://twikoo-comment.shenxiaohai.me/","el":"#twikoo-comments"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.twikoo.el)
    .then(() => NexT.utils.getScript(
      CONFIG.twikoo.jsUrl || 'https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js',
      { condition: window.twikoo }
    ))
    .then(() => {
      twikoo.init(CONFIG.twikoo);
    });
});
</script>
<style>
.post-block, .comments {
  overflow: visible;
}
.tk-owo-emotion {
  display: inline-block;
}
</style>

</body>
</html>
